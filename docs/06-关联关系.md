# 关联关系

本章节介绍如何在 OCORM 中定义实体间的关联关系，包括 OneToMany、ManyToOne 和 ManyToMany 三种类型。

## 概述

OCORM 支持三种关联关系类型：

| 关系类型 | 说明 | 示例 |
|---------|------|------|
| **OneToMany** | 一对多 | 一个用户有多个订单 |
| **ManyToOne** | 多对一 | 多个订单属于一个用户 |
| **ManyToMany** | 多对多 | 用户和角色，一个用户有多个角色，一个角色属于多个用户 |

## 注册关联关系

### 导入必要的模块

```typescript
import {
  MetadataStorage,
  RelationMetadata,
  ManyToManyMetadata,
  RelationType
} from 'ocorm'
```

## 一对多关系（OneToMany）

### 定义示例：用户和订单

```typescript
// entities/User.ts
import {
  registerEntity,
  registerAutoIncrementPrimaryKey,
  createEntityOptions
} from 'ocorm'

registerEntity('User', createEntityOptions('users'))
registerAutoIncrementPrimaryKey('User', 'id', 'id')
// ... 注册其他列

// entities/Order.ts
import { registerEntity, registerAutoIncrementPrimaryKey, createEntityOptions } from 'ocorm'

registerEntity('Order', createEntityOptions('orders'))
registerAutoIncrementPrimaryKey('Order', 'id', 'id')
registerPrimaryKey('Order', 'userId', 'user_id')  // 外键列
// ... 注册其他列
```

### 注册关联

```typescript
// associations.ts
import { MetadataStorage, RelationType } from 'ocorm'

const storage = MetadataStorage.getInstance()

// User -> Order (一个用户有多个订单)
storage.registerRelation('User', {
  type: RelationType.ONE_TO_MANY,
  targetEntity: 'Order',
  propertyName: 'orders',
  inverseKey: 'user_id'  // Order 表中的外键列名
})

// Order -> User (一个订单属于一个用户)
storage.registerRelation('Order', {
  type: RelationType.MANY_TO_ONE,
  targetEntity: 'User',
  propertyName: 'user',
  foreignKey: 'user_id'  // 本表的外键列名
})
```

## 多对一关系（ManyToOne）

多对一关系通常与一对多关系配合使用。在上例中，`Order` 实体通过 `user_id` 外键关联到 `User` 实体，这就是多对一关系。

```typescript
// 查询订单时加载关联的用户
const orders = await orderRepo.createQueryBuilder()
  .where('status', ConditionOperator.EQUAL, 1)
  .with('user')  // 加载关联的 User
  .getMany()

orders.forEach(order => {
  const userData = order.getRelatedData('user')
  if (userData) {
    console.info(`订单用户: ${userData.getPropertyValue('name')}`)
  }
})
```

## 多对多关系（ManyToMany）

### 定义示例：用户和角色

```typescript
// entities/User.ts
// 注册 User 实体的列...

// entities/Role.ts
import {
  registerEntity,
  registerAutoIncrementPrimaryKey,
  createEntityOptions
} from 'ocorm'

registerEntity('Role', createEntityOptions('roles'))
registerAutoIncrementPrimaryKey('Role', 'id', 'id')

// ... 注册角色名称等列
```

### 注册多对多关联

```typescript
// associations.ts
import { ManyToManyMetadata } from 'ocorm'

const storage = MetadataStorage.getInstance()

// User <-> Role (中间表: user_roles)
storage.registerManyToMany('User', new ManyToManyMetadata(
  'User',           // 源实体
  'Role',           // 目标实体
  'roles',          // User 实体的关联属性名
  'user_roles',     // 中间表名
  'user_id',        // 中间表中源实体的外键列
  'role_id'         // 中间表中目标实体的外键列
))

// 反向关联（Role -> Users）
storage.registerManyToMany('Role', new ManyToManyMetadata(
  'Role',
  'User',
  'users',
  'user_roles',
  'role_id',
  'user_id'
))
```

### 自动创建中间表

多对多关系的中间表需要手动创建：

```typescript
// schema/UserRoleSchema.ts
export function createUserRoleTableSql(): string {
  return `
    CREATE TABLE IF NOT EXISTS user_roles (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL,
      role_id INTEGER NOT NULL,
      created_at INTEGER,
      UNIQUE(user_id, role_id)
    )
  `
}
```

在初始化数据库时执行：

```typescript
import { DatabaseManager } from 'ocorm'

async function initDatabase(context: Context) {
  // ... 初始化数据库管理器
  
  const store = DatabaseManager.getInstance().getStore()
  
  // 创建中间表
  await store.executeSql(createUserRoleTableSql())
}
```

## 加载关联数据

### 使用 with() 方法

```typescript
const users = await userRepo.createQueryBuilder()
  .where('status', ConditionOperator.EQUAL, 1)
  .with('orders')    // 加载订单
  .with('roles')     // 加载角色
  .getMany()

// 获取关联数据
users.forEach(user => {
  // 获取订单列表
  const orders = user.getRelatedData('orders') as EntityData[]
  console.info(`用户 ${user.getPropertyValue('name')} 有 ${orders.length} 个订单`)
  
  // 获取角色列表
  const roles = user.getRelatedData('roles') as EntityData[]
  console.info(`用户角色: ${roles.map(r => r.getPropertyValue('name')).join(', ')}`)
})
```

### 并行加载多个关联

OCORM 会自动并行加载多个关联关系：

```typescript
// 三个关联会并行查询，提升性能
const users = await userRepo.createQueryBuilder()
  .where('status', ConditionOperator.EQUAL, 1)
  .with('orders')
  .with('profile')
  .with('roles')
  .getMany()
```

## 管理多对多关联

### 附加关联（attach）

```typescript
// 为用户附加角色
await userRepo.attach(userId, roleId, 'roles')
```

### 解除关联（detach）

```typescript
// 移除用户的角色
await userRepo.detach(userId, roleId, 'roles')
```

### 同步关联（sync）

```typescript
// 同步用户的角色（替换所有现有关联）
await userRepo.sync(userId, [roleId1, roleId2, roleId3], 'roles')
```

## 完整示例

### 定义实体和关联

```typescript
// entities/index.ts
import {
  MetadataStorage,
  ColumnMetadata,
  ColumnType,
  RelationMetadata,
  ManyToManyMetadata,
  RelationType
} from 'ocorm'
import {
  registerEntity,
  registerAutoIncrementPrimaryKey,
  registerPrimaryKey,
  createEntityOptions
} from 'ocorm'

// ========== User 实体 ==========
export function registerUserEntity(): void {
  registerEntity('User', createEntityOptions('users'))
  registerAutoIncrementPrimaryKey('User', 'id', 'id')
  
  const storage = MetadataStorage.getInstance()
  
  const nameColumn = new ColumnMetadata('name', 'name')
  nameColumn.columnType = ColumnType.TEXT
  nameColumn.isNullable = false
  storage.registerColumn('User', nameColumn)
  
  const emailColumn = new ColumnMetadata('email', 'email')
  emailColumn.columnType = ColumnType.TEXT
  emailColumn.isUnique = true
  storage.registerColumn('User', emailColumn)
}

// ========== Role 实体 ==========
export function registerRoleEntity(): void {
  registerEntity('Role', createEntityOptions('roles'))
  registerAutoIncrementPrimaryKey('Role', 'id', 'id')
  
  const storage = MetadataStorage.getInstance()
  
  const nameColumn = new ColumnMetadata('name', 'name')
  nameColumn.columnType = ColumnType.TEXT
  nameColumn.isUnique = true
  storage.registerColumn('Role', nameColumn)
}

// ========== Order 实体 ==========
export function registerOrderEntity(): void {
  registerEntity('Order', createEntityOptions('orders'))
  registerAutoIncrementPrimaryKey('Order', 'id', 'id')
  registerPrimaryKey('Order', 'userId', 'user_id')
  
  const storage = MetadataStorage.getInstance()
  
  const amountColumn = new ColumnMetadata('amount', 'amount')
  amountColumn.columnType = ColumnType.REAL
  amountColumn.isNullable = false
  storage.registerColumn('Order', amountColumn)
  
  const statusColumn = new ColumnMetadata('status', 'status')
  statusColumn.columnType = ColumnType.INTEGER
  statusColumn.defaultValue = 0
  storage.registerColumn('Order', statusColumn)
}

// ========== 注册关联 ==========
export function registerAllRelations(): void {
  const storage = MetadataStorage.getInstance()
  
  // User -> Order (一对多)
  storage.registerRelation('User', {
    type: RelationType.ONE_TO_MANY,
    targetEntity: 'Order',
    propertyName: 'orders',
    inverseKey: 'user_id'
  })
  
  // Order -> User (多对一)
  storage.registerRelation('Order', {
    type: RelationType.MANY_TO_ONE,
    targetEntity: 'User',
    propertyName: 'user',
    foreignKey: 'user_id'
  })
  
  // User -> Role (多对多)
  storage.registerManyToMany('User', new ManyToManyMetadata(
    'User', 'Role', 'roles',
    'user_roles', 'user_id', 'role_id'
  ))
  
  // Role -> User (多对多，反向)
  storage.registerManyToMany('Role', new ManyToManyMetadata(
    'Role', 'User', 'users',
    'user_roles', 'role_id', 'user_id'
  ))
}

// 统一初始化
export function initializeEntities(): void {
  registerUserEntity()
  registerRoleEntity()
  registerOrderEntity()
  registerAllRelations()
}
```

### 使用关联查询

```typescript
// services/UserService.ts
import { Repository, EntityData, ConditionOperator } from 'ocorm'

export class UserService {
  private userRepo: Repository
  private orderRepo: Repository
  private roleRepo: Repository
  
  constructor() {
    this.userRepo = new Repository('User')
    this.orderRepo = new Repository('Order')
    this.roleRepo = new Repository('Role')
  }
  
  // 获取用户及其所有关联数据
  async getUserWithRelations(userId: number): Promise<EntityData | null> {
    const users = await this.userRepo.createQueryBuilder()
      .where('id', ConditionOperator.EQUAL, userId)
      .with('orders')
      .with('roles')
      .getMany()
    
    return users.length > 0 ? users[0] : null
  }
  
  // 获取订单及其用户信息
  async getOrdersWithUsers(status: number): Promise<EntityData[]> {
    return await this.orderRepo.createQueryBuilder()
      .where('status', ConditionOperator.EQUAL, status)
      .with('user')
      .orderBy('createdAt', 'DESC')
      .getMany()
  }
  
  // 为用户分配角色
  async assignRoles(userId: number, roleIds: number[]): Promise<void> {
    await this.userRepo.sync(userId, roleIds, 'roles')
  }
  
  // 移除用户的所有角色
  async removeAllRoles(userId: number): Promise<void> {
    const user = await this.getUserWithRelations(userId)
    if (user) {
      const roles = user.getRelatedData('roles') as EntityData[]
      for (const role of roles) {
        await this.userRepo.detach(userId, role.getPropertyValue('id') as number, 'roles')
      }
    }
  }
}
```

## 关联查询性能优化

### 使用并行加载

```typescript
// 同时加载多个关联，OCORM 会并行执行查询
const users = await userRepo.createQueryBuilder()
  .with('orders')   // 并行查询
  .with('roles')    // 并行查询
  .with('profile')  // 并行查询
  .getMany()
```

### 限制关联数据量

```typescript
// 只加载最近的 10 个订单
const users = await userRepo.createQueryBuilder()
  .with('orders')
  .limit(10)  // 注意：这会限制主查询结果数量
  .getMany()
```

对于更复杂的关联数据限制，建议在业务逻辑中过滤：

```typescript
const users = await userRepo.createQueryBuilder()
  .with('orders')
  .getMany()

// 在代码中过滤
users.forEach(user => {
  const orders = (user.getRelatedData('orders') as EntityData[])
    .slice(0, 10)  // 只取前 10 个
})
```

## 下一步

- [事务与批量操作](07-事务与批量操作.md) - 在关联操作中使用事务
- [性能优化](13-性能优化.md) - 优化关联查询性能
- [完整示例](16-完整示例.md) - 查看完整的业务场景示例




