# 常见问题 (FAQ)

本章节收集了使用 OCORM 时的常见问题和解决方案。

## 安装与配置

### Q1: 如何将 OCORM 添加到项目中？

**答**: 在项目的 `oh-package.json5` 中添加依赖：

```json5
{
  "dependencies": {
    "ocorm": "file:../OCORM"
  }
}
```

然后执行 `npm install` 安装依赖。

### Q2: 数据库初始化失败怎么办？

**答**: 检查以下几点：

1. 确保 `context` 参数正确传递（需要应用上下文）
2. 检查安全级别是否支持
3. 确保应用有存储权限

```typescript
// 错误处理示例
try {
  await DatabaseManager.getInstance().initialize(context, config)
} catch (error) {
  console.error(`初始化失败: ${error.message}`)
}
```

### Q3: 如何配置查询缓存？

**答**: 在 `DatabaseConfig` 中启用：

```typescript
const config = new DatabaseConfig('myapp.db', relationalStore.SecurityLevel.S1)
config.enableQueryCache = true
config.queryCacheMaxSize = 200      // 最大条目数
config.queryCacheTtlMs = 60000      // 过期时间（毫秒）
```

## 实体定义

### Q4: 实体类需要继承某个基类吗？

**答**: 不需要。OCORM 采用轻量级设计，实体类可以是普通的 TypeScript 类。

### Q5: 如何定义主键？

**答**: 推荐使用自增主键：

```typescript
registerAutoIncrementPrimaryKey('User', 'id', 'id')
```

或手动指定主键：

```typescript
registerPrimaryKey('User', 'uuid', 'uuid')
```

### Q6: 列名和属性名可以不同吗？

**答**: 可以。在创建 `ColumnMetadata` 时分别指定：

```typescript
const column = new ColumnMetadata('userId', 'user_id')  // 属性名, 列名
```

### Q7: 实体未注册错误怎么办？

**答**: 确保在使用 Repository 之前调用了实体注册函数：

```typescript
// 错误
const repo = new Repository('User')  // 可能报错

// 正确
registerUserEntity()  // 先注册
const repo = new Repository('User')  // 再使用
```

### Q8: TEXT 类型最大长度如何设置？

**答**:

```typescript
const column = new ColumnMetadata('content', 'content')
column.columnType = ColumnType.TEXT
column.length = 500  // 最大 500 字符
```

## CRUD 操作

### Q9: save() 和 update() 有什么区别？

**答**: OCORM 的 `save()` 方法会自动判断：
- 主键为 0 或 null → 执行 INSERT
- 主键有值 → 执行 UPDATE

```typescript
// 新建（INSERT）
const user = EntityData.from('User', { name: '新用户' })
await repo.save(user)  // INSERT

// 更新（UPDATE）
user.setPropertyValue('name', '修改后的名字')
await repo.save(user)  // UPDATE
```

### Q10: 如何批量插入数据？

**答**: 使用 `batchInsert()` 方法：

```typescript
const users = [
  EntityData.from('User', { name: '用户1' }),
  EntityData.from('User', { name: '用户2' })
]
const result = await repo.batchInsert(users, new BatchInsertOptions())
console.info(`成功: ${result.insertedCount}`)
```

### Q11: findById 返回 null 怎么办？

**答**: 检查主键值是否正确，以及数据是否存在：

```typescript
const user = await repo.findById(1)
if (!user) {
  console.info('用户不存在')
}
```

### Q12: 如何实现软删除？

**答**: 在注册实体时启用软删除：

```typescript
registerEntity('User', createEntityOptions('users', true))  // 第二个参数 true 启用软删除
```

然后使用 `remove()` 进行软删除，`restore()` 恢复数据，`withDeleted()` 查询已删除数据。

## 查询构建

### Q13: 条件操作符有哪些？

**答**:

| 操作符 | 说明 |
|-------|------|
| `EQUAL` | 等于 |
| `NOT_EQUAL` | 不等于 |
| `GREATER` | 大于 |
| `GREATER_OR_EQUAL` | 大于等于 |
| `LESS` | 小于 |
| `LESS_OR_EQUAL` | 小于等于 |
| `LIKE` | 模糊匹配 |
| `IN` | 在列表中 |
| `IS_NULL` | 为空 |

### Q14: 如何实现分页查询？

**答**: 使用 `paginate()` 方法：

```typescript
const result = await repo.createQueryBuilder()
  .orderBy('createdAt', 'DESC')
  .paginate(1, 20)  // 第 1 页，每页 20 条
  .getPaginated()

console.info(`共 ${result.total} 条数据`)
console.info(`当前第 ${result.page}/${result.totalPages} 页`)
```

### Q15: 如何加载关联数据？

**答**: 使用 `with()` 方法：

```typescript
const users = await userRepo.createQueryBuilder()
  .with('orders')    // 加载订单
  .with('roles')     // 加载角色
  .getMany()

// 获取关联数据
users.forEach(user => {
  const orders = user.getRelatedData('orders') as EntityData[]
})
```

### Q16: 关联查询报 RelationNotFoundError 怎么办？

**答**: 确保已注册关联关系：

```typescript
storage.registerRelation('User', {
  type: RelationType.ONE_TO_MANY,
  targetEntity: 'Order',
  propertyName: 'orders',
  inverseKey: 'user_id'
})
```

## 事务

### Q17: 事务中的操作会回滚吗？

**答**: 是的。如果事务中的任何操作失败，所有更改都会自动回滚：

```typescript
await repo.transaction(async (txRepo) => {
  await txRepo.save(user1)
  await txRepo.save(user2)  // 如果这里失败，user1 也会回滚
})
```

### Q18: 事务可以嵌套吗？

**答**: 不支持嵌套事务。如需复杂事务，请在单个事务中完成所有操作。

## 性能

### Q19: 大数据量查询慢怎么办？

**答**: 建议：

1. 使用分页查询
2. 启用查询缓存
3. 添加合适的索引
4. 使用 `findAllAsync()` 异步查询

```typescript
// 分页
const result = await repo.findPaginated(1, 20)

// 异步查询
const users = await repo.findAllAsync()

// 添加索引（在迁移中）
await store.executeSql(`CREATE INDEX idx_users_status ON users(status)`)
```

### Q20: 批量插入太慢怎么办？

**答**: 使用 `batchInsert()` 并配置事务：

```typescript
const options = new BatchInsertOptions()
options.useTransaction = true  // 使用事务（推荐）
await repo.batchInsert(users, options)
```

## 钩子

### Q21: 钩子不执行怎么办？

**答**: 检查以下几点：

1. 实体是否配置了钩子
2. 批量操作是否启用了钩子（`executeHooks` 选项）
3. 钩子函数是否有错误

```typescript
// 批量插入时启用钩子
const options = new BatchInsertOptions()
options.executeHooks = true
```

### Q22: 钩子中可以使用异步操作吗？

**答**: 可以。钩子函数可以返回 `Promise<void>`：

```typescript
const hooks = new EntityHooks(
  async (data) => {
    // 异步操作
    await someAsyncOperation()
  }
)
```

## 错误处理

### Q23: 如何区分不同类型的错误？

**答**: 使用 `instanceof` 检查错误类型：

```typescript
try {
  await repo.save(data)
} catch (error) {
  if (error instanceof EntityNotRegisteredError) {
    // 处理实体未注册错误
  } else if (error instanceof HookExecutionError) {
    // 处理钩子错误
  } else if (error instanceof OrmError) {
    // 处理其他 ORM 错误
  }
}
```

### Q24: 如何获取详细的错误信息？

**答**: 查看错误的 `message` 和 `code` 属性：

```typescript
catch (error) {
  console.error(`错误码: ${error.code}`)
  console.error(`错误信息: ${error.message}`)
  console.error(`堆栈: ${error.stack}`)
}
```

## 兼容性与限制

### Q25: OCORM 支持哪些 HarmonyOS 版本？

**答**: 
- HarmonyOS NEXT (API 17+)
- OpenHarmony 5.0+

### Q26: SQLite 有哪些限制？

**答**:
- 不支持删除列（需要重建表）
- 不支持重命名列（需要重建表）
- 不支持复合主键的自增
- 全文索引需要扩展

### Q27: 是否支持加密数据库？

**答**: 是的，通过配置 `encrypt` 选项：

```typescript
const config = new DatabaseConfig('encrypted.db', relationalStore.SecurityLevel.S3)
config.encrypt = true
```

## 调试

### Q28: 如何查看执行的 SQL？

**答**: 启用日志并设置合适的日志级别：

```typescript
const config = new DatabaseConfig('myapp.db', relationalStore.SecurityLevel.S1)
config.enableLogger = true
config.loggerLevel = LogLevel.DEBUG
```

### Q29: 如何排查性能问题？

**答**: 
1. 启用 DEBUG 日志查看慢查询
2. 使用缓存减少重复查询
3. 分析查询日志找出瓶颈
4. 添加合适的数据库索引

```typescript
// 查看慢查询（超过 100ms）
const slowQueries = logger.getLogsByType('Query')
  .filter(log => (log.duration || 0) > 100)
```

## 其他

### Q30: 如何迁移到新版本？

**答**:
1. 阅读版本更新说明
2. 在测试环境验证
3. 使用数据库迁移管理 Schema 变更
4. 备份生产数据后再升级

### Q31: 如何贡献代码或报告 Bug？

**答**: 请联系项目维护者或查看项目仓库的贡献指南。

### Q32: 是否有完整的示例项目？

**答**: 是的，请参考 [完整示例](16-完整示例.md) 章节。

## 快速索引

| 问题类型 | 常见问题 |
|---------|---------|
| 安装配置 | 初始化失败、依赖添加 |
| 实体定义 | 主键、列名映射、软删除 |
| CRUD 操作 | save()、批量插入、分页 |
| 查询构建 | 条件操作符、关联加载 |
| 性能优化 | 缓存、批量操作、索引 |
| 错误处理 | 错误类型区分、详细信息 |
</think>


<minimax:tool_call>
<invoke name="write">
<parameter name="contents"># 项目结构推荐

本章节介绍使用 OCORM 开发 HarmonyOS 应用的推荐项目结构和组织方式。

## 推荐目录结构

```
entry/src/main/ets/
├── common/                    # 公共工具和常量
│   ├── constants/             # 常量定义
│   │   └── DatabaseConstants.ts
│   └── utils/                 # 工具类
│       ├── Logger.ts
│       └── ErrorHandler.ts
├── database/                  # 数据库相关
│   ├── DBManager.ts           # 数据库管理器
│   ├── DatabaseConfig.ts      # 数据库配置（可选）
│   └── migrations/            # 数据库迁移
│       ├── index.ts
│       ├── 001_initial.ts
│       └── 002_add_user_status.ts
├── entities/                  # 实体定义
│   ├── index.ts               # 实体注册入口
│   ├── User.ts
│   ├── Order.ts
│   └── Role.ts
├── associations/              # 关联关系定义
│   ├── index.ts               # 关联注册入口
│   └── UserRelations.ts
├── hooks/                     # 生命周期钩子
│   ├── index.ts               # 钩子注册入口
│   ├── UserHooks.ts
│   └── CommonHooks.ts
├── repositories/              # 仓储层
│   ├── index.ts
│   ├── UserRepository.ts
│   └── OrderRepository.ts
├── services/                  # 业务服务层
│   ├── index.ts
│   ├── UserService.ts
│   └── OrderService.ts
├── mappers/                   # ViewModel 映射器
│   ├── index.ts
│   └── UserMapper.ts
├── viewmodels/                # ViewModel（可选，用于 MVVM）
│   └── UserListViewModel.ts
├── pages/                     # 页面
│   ├── Index.ets
│   └── UserDetail.ets
└── EntryAbility.ts            # 应用入口
```

## 模块职责说明

### 1. 实体层 (entities/)

负责定义数据实体和注册。

```typescript
// entities/User.ts
import {
  MetadataStorage,
  ColumnMetadata,
  ColumnType,
  registerEntity,
  registerAutoIncrementPrimaryKey,
  createEntityOptions
} from 'ocorm'
import { createUserHooks } from '../hooks/UserHooks'

export function registerUserEntity(): void {
  // 注册实体（启用软删除和钩子）
  registerEntity('User', createEntityOptions('users', true, createUserHooks()))
  
  // 注册主键
  registerAutoIncrementPrimaryKey('User', 'id', 'id')
  
  // 注册列
  const storage = MetadataStorage.getInstance()
  
  const nameColumn = new ColumnMetadata('name', 'name')
  nameColumn.columnType = ColumnType.TEXT
  nameColumn.isNullable = false
  storage.registerColumn('User', nameColumn)
  
  // ... 其他列
}
```

### 2. 关联层 (associations/)

负责定义实体间的关联关系。

```typescript
// associations/UserRelations.ts
import { MetadataStorage, RelationType } from 'ocorm'

export function registerUserRelations(): void {
  const storage = MetadataStorage.getInstance()
  
  // User -> Order (一对多)
  storage.registerRelation('User', {
    type: RelationType.ONE_TO_MANY,
    targetEntity: 'Order',
    propertyName: 'orders',
    inverseKey: 'user_id'
  })
  
  // ... 其他关联
}
```

### 3. 钩子层 (hooks/)

负责定义生命周期钩子。

```typescript
// hooks/UserHooks.ts
import { EntityHooks } from 'ocorm'

export function createUserHooks(): EntityHooks {
  return new EntityHooks(
    // beforeSave
    (data) => {
      const now = Date.now()
      if (!data.getProperty('createdAt')) {
        data.setPropertyValue('createdAt', now)
      }
      data.setPropertyValue('updatedAt', now)
    },
    
    // afterLoad
    (data) => {
      // 数据处理逻辑
    }
  )
}
```

### 4. 仓储层 (repositories/)

负责数据访问的封装。

```typescript
// repositories/UserRepository.ts
import { Repository, EntityData } from 'ocorm'

export class UserRepository {
  private repo: Repository

  constructor() {
    this.repo = new Repository('User')
  }

  async findById(id: number): Promise<EntityData | null> {
    return await this.repo.findById(id)
  }

  async findAll(): Promise<EntityData[]> {
    return await this.repo.findAll()
  }

  async save(data: EntityData): Promise<void> {
    await this.repo.save(data)
  }

  // ... 其他数据访问方法
}
```

### 5. 服务层 (services/)

负责业务逻辑。

```typescript
// services/UserService.ts
import { UserRepository } from '../repositories/UserRepository'
import { EntityData, ConditionOperator } from 'ocorm'

export class UserService {
  private userRepo: UserRepository

  constructor() {
    this.userRepo = new UserRepository()
  }

  async createUser(name: string, email: string): Promise<number | null> {
    const userData = EntityData.from('User', {
      name: name,
      email: email
    })
    
    const result = await this.userRepo.save(userData)
    return result.success ? result.insertId : null
  }

  async getActiveUsers(): Promise<EntityData[]> {
    return await this.userRepo.createQueryBuilder()
      .where('status', ConditionOperator.EQUAL, 1)
      .orderBy('createdAt', 'DESC')
      .getMany()
  }

  // ... 其他业务方法
}
```

### 6. 映射器层 (mappers/)

负责 EntityData 与 ViewModel 之间的转换。

```typescript
// mappers/UserMapper.ts
import { ViewModelMapper, EntityData } from 'ocorm'

export class UserListItem {
  id: number = 0
  name: string = ''
  email: string = ''
}

export class UserMapper {
  static toListItem(data: EntityData): UserListItem {
    return ViewModelMapper.toViewModel<UserListItem>(
      data,
      () => new UserListItem(),
      (data, vm) => {
        vm.id = data.getPropertyValue('id') as number
        vm.name = data.getPropertyValue('name') as string
        vm.email = data.getPropertyValue('email') as string
      }
    )
  }

  static toListItems(dataArray: EntityData[]): UserListItem[] {
    return ViewModelMapper.toViewModelArray<UserListItem>(
      dataArray,
      () => new UserListItem(),
      (data, vm) => {
        vm.id = data.getPropertyValue('id') as number
        vm.name = data.getPropertyValue('name') as string
        vm.email = data.getPropertyValue('email') as string
      }
    )
  }
}
```

## 初始化入口

```typescript
// entities/index.ts
import { registerUserEntity } from './User'
import { registerOrderEntity } from './Order'
import { registerRoleEntity } from './Role'

export function registerAllEntities(): void {
  registerUserEntity()
  registerOrderEntity()
  registerRoleEntity()
  
  const count = MetadataStorage.getInstance().getAllEntities().length
  console.info(`已注册 ${count} 个实体`)
}

// associations/index.ts
import { registerUserRelations } from './UserRelations'
import { registerOrderRelations } from './OrderRelations'

export function registerAllRelations(): void {
  registerUserRelations()
  registerOrderRelations()
}

// hooks/index.ts
export { createUserHooks } from './UserHooks'
export { createOrderHooks } from './OrderHooks'

// main.ts - 应用初始化
import { registerAllEntities } from './entities'
import { registerAllRelations } from './associations'

export function initDatabase(context: Context): Promise<void> {
  // 1. 注册所有实体
  registerAllEntities()
  
  // 2. 注册所有关联
  registerAllRelations()
  
  // 3. 初始化数据库
  // ...
}
```

## 依赖关系

```
┌─────────────────────────────────────────────────┐
│                   Pages (UI 层)                  │
│              依赖 services 和 viewmodels          │
└─────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────┐
│                Services (服务层)                 │
│              依赖 repositories 和 mappers        │
└─────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────┐
│              Repositories (仓储层)               │
│              依赖 entities 和 OCORM              │
└─────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────┐
│           Entities + Associations + Hooks        │
│              依赖 MetadataStorage                │
└─────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────┐
│                   OCORM 核心                     │
│         依赖 @ohos.data.relationalStore         │
└─────────────────────────────────────────────────┘
```

## 最佳实践

### 1. 单一职责

每个模块只负责一种职责：
- **Entity**：定义数据结构
- **Repository**：封装数据访问
- **Service**：封装业务逻辑
- **Mapper**：处理数据转换

### 2. 依赖注入

使用依赖注入解耦模块：

```typescript
// 好的做法：依赖抽象
interface IUserRepository {
  findById(id: number): Promise<EntityData | null>
}

class UserRepositoryImpl implements IUserRepository {
  // 实现...
}

class UserService {
  constructor(private userRepo: IUserRepository) {}
}
```

### 3. 错误处理

在服务层统一处理错误：

```typescript
// services/UserService.ts
export class UserService {
  async getUserById(id: number): Promise<UserDetailVM | null> {
    try {
      const user = await this.userRepo.findById(id)
      if (!user) return null
      return UserMapper.toDetail(user)
    } catch (error) {
      console.error(`获取用户失败: ${error.message}`)
      return null
    }
  }
}
```

### 4. 单元测试

为每个层编写单元测试：

```typescript
// tests/unit/repositories/UserRepository.test.ts
import { UserRepository } from '../../src/repositories/UserRepository'

describe('UserRepository', () => {
  let repo: UserRepository
  
  beforeEach(() => {
    repo = new UserRepository()
  })
  
  it('should find user by id', async () => {
    const user = await repo.findById(1)
    expect(user).not.toBeNull()
  })
})
```

## 下一步

- [完整示例](16-完整示例.md) - 查看完整的业务场景示例
- [性能优化](13-性能优化.md) - 优化项目性能
