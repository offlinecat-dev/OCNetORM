# 性能优化

本章节介绍 OCORM 的性能优化策略，包括查询优化、缓存策略和最佳实践。

## 性能优化概览

| 优化点 | 预期效果 | 适用场景 |
|-------|---------|---------|
| 查询缓存 | 减少 90%+ 重复查询 | 频繁读取的数据 |
| 批量操作 | 提升 10-100 倍写入 | 大量数据插入 |
| 并行关联加载 | 减少 30-50% 延迟 | 多关联查询 |
| 异步数据转换 | 避免主线程阻塞 | 大结果集处理 |
| 分页查询 | 减少内存占用 | 大数据集展示 |

## 查询缓存

### 启用缓存

```typescript
import { DatabaseConfig, QueryCache } from 'ocorm'
import { relationalStore } from '@kit.ArkData'

const config = new DatabaseConfig('myapp.db', relationalStore.SecurityLevel.S1)

// 启用查询缓存
config.enableQueryCache = true
config.queryCacheMaxSize = 200    // 最大缓存条目数
config.queryCacheTtlMs = 60000    // 缓存过期时间（1 分钟）
```

### 缓存配置

```typescript
const cache = QueryCache.getInstance()

// 手动配置
cache.configure({
  enabled: true,
  maxSize: 200,
  ttlMs: 120000  // 2 分钟
})

// 查看缓存统计
const stats = cache.getStatistics()
console.info(`命中次数: ${stats.hits}`)
console.info(`未命中次数: ${stats.misses}`)
console.info(`命中率: ${(stats.hitRate * 100).toFixed(2)}%`)
console.info(`当前缓存大小: ${stats.size}`)
```

### 缓存键设计

OCORM 使用特殊分隔符（空字符 `\x00`）生成缓存键，确保实体名或 ID 中包含特殊字符时不会产生键冲突。

```typescript
// 缓存键格式: entityName\x00id
// 例如: User\x0012345
```

### 缓存失效

```typescript
const cache = QueryCache.getInstance()

// 使单个缓存失效
cache.invalidate('User', 1)

// 使整个实体缓存失效
cache.invalidateEntity('User')

// 清空所有缓存
cache.clear()
```

## 批量操作优化

### 批量插入性能对比

```typescript
// 测试数据：1000 条用户记录
const testUsers: EntityData[] = generateTestUsers(1000)

// 方式 1：逐条保存
const start1 = Date.now()
for (const user of testUsers) {
  await repo.save(user)
}
console.info(`逐条保存: ${Date.now() - start1}ms`)  // ~5000ms

// 方式 2：批量插入
const start2 = Date.now()
const result = await repo.batchInsert(testUsers, new BatchInsertOptions())
console.info(`批量插入: ${Date.now() - start2}ms`)  // ~100ms
```

### 批量插入配置

```typescript
const options = new BatchInsertOptions()
options.useTransaction = true    // 使用事务（推荐）
options.executeHooks = true      // 执行钩子（可选）

// 大批量数据时分批处理
async function batchInsertLargeData(
  data: EntityData[],
  batchSize: number = 500
): Promise<void> {
  for (let i = 0; i < data.length; i += batchSize) {
    const batch = data.slice(i, i + batchSize)
    await repo.batchInsert(batch, new BatchInsertOptions())
    console.info(`进度: ${Math.min(i + batchSize, data.length)}/${data.length}`)
  }
}
```

## 并行关联加载

### 使用 with() 方法

```typescript
// 串行加载（3 个关联需要 3 次查询）
const users1 = await userRepo.createQueryBuilder()
  .with('orders')
  .getMany()  // 先查询用户，再查询订单

const users2 = await userRepo.createQueryBuilder()
  .with('roles')
  .getMany()  // 先查询用户，再查询角色

// 并行加载（OCORM 自动优化）
const users = await userRepo.createQueryBuilder()
  .with('orders')   // 并行执行
  .with('roles')    // 并行执行
  .with('profile')  // 并行执行
  .getMany()        // 三个关联同时查询
```

## 异步数据转换

### findAllAsync

```typescript
// 同步查询（大数据量会阻塞）
const users1 = await repo.findAll()

// 异步查询（使用 TaskPool）
const users2 = await repo.findAllAsync()

// QueryBuilder 也支持异步
const users3 = await repo.createQueryBuilder()
  .where('status', ConditionOperator.EQUAL, 1)
  .getAsync()  // 数据量 > 100 时自动使用 TaskPool
```

### 异步查询配置

```typescript
import { QueryExecutor } from 'ocorm'

const executor = new QueryExecutor(queryBuilder)

// 设置异步转换阈值
executor.setAsyncThreshold(50)  // 数据量 > 50 时使用异步

// 手动触发异步
const result = await executor.getAsync()
```

## 分页查询优化

### 使用分页

```typescript
// 不使用分页（加载全部数据）
const allUsers = await repo.findAll()  // 可能很慢

// 使用分页（只加载当前页）
const result = await repo.createQueryBuilder()
  .orderBy('createdAt', 'DESC')
  .paginate(1, 20)  // 只加载前 20 条
  .getPaginated()

console.info(`第 ${result.page}/${result.totalPages} 页`)
console.info(`共 ${result.total} 条数据`)
```

### 大数据量分页

对于大数据量，深度分页可能较慢：

```typescript
// ❌ 慢：深度分页
await repo.createQueryBuilder()
  .paginate(10000, 20)  // 需要跳过 20000 条记录

// ✅ 快：基于 ID 的分页
const lastId = 10000
const users = await repo.createQueryBuilder()
  .where('id', ConditionOperator.GREATER, lastId)
  .orderBy('id', 'ASC')
  .limit(20)
  .getMany()
```

## 索引优化

### 创建索引

```typescript
// 在迁移中添加索引
async up(store: relationalStore.RdbStore): Promise<void> {
  // 为常用查询条件创建索引
  await store.executeSql(`
    CREATE INDEX idx_users_status ON users(status)
  `)
  
  await store.executeSql(`
    CREATE INDEX idx_users_email ON users(email)
  `)
  
  await store.executeSql(`
    CREATE INDEX idx_users_created_at ON users(created_at)
  `)
  
  // 复合索引
  await store.executeSql(`
    CREATE INDEX idx_users_status_created ON users(status, created_at)
  `)
}
```

### 索引使用建议

| 场景 | 索引建议 |
|-----|---------|
| 等值查询（=） | 单列索引 |
| 范围查询（>, <） | 单列索引 |
| 排序（ORDER BY） | 排序字段索引 |
| 多条件查询 | 复合索引 |
| LIKE 前缀匹配 | 单列索引 |
| LIKE 全模糊 | 全文索引（需扩展） |

## 查询优化技巧

### 1. 只查询需要的列

```typescript
// ❌ 查询所有列
const users = await repo.createQueryBuilder()
  .getMany()

// ✅ 只查询需要的列
const users = await repo.createQueryBuilder()
  .select(['id', 'name', 'email'])
  .getMany()
```

### 2. 避免 N+1 查询

```typescript
// ❌ N+1 查询
const users = await repo.findAll()
for (const user of users) {
  const orders = await orderRepo.createQueryBuilder()
    .where('userId', ConditionOperator.EQUAL, user.getPropertyValue('id'))
    .getMany()
}

// ✅ 使用关联加载
const usersWithOrders = await userRepo.createQueryBuilder()
  .with('orders')
  .getMany()
```

### 3. 使用查询缓存

```typescript
const cache = QueryCache.getInstance()

// 配置缓存
cache.configure({
  enabled: true,
  maxSize: 100,
  ttlMs: 30000
})

// findById 默认使用缓存
const user1 = await repo.findById(1)  // 从数据库查询
const user2 = await repo.findById(1)  // 从缓存获取
```

### 4. 批量操作使用事务

```typescript
// ✅ 使用事务
const options = new BatchInsertOptions()
options.useTransaction = true
await repo.batchInsert(users, options)

// ❌ 不使用事务
const optionsNoTx = new BatchInsertOptions()
optionsNoTx.useTransaction = false
await repo.batchInsert(users, optionsNoTx)  // 可能导致数据不一致
```

## 性能监控

### 监控查询性能

```typescript
import { Logger } from 'ocorm'

const logger = Logger.getInstance()

// 获取慢查询
const slowQueries = logger.getLogsByType('Query')
  .filter(log => (log.duration || 0) > 100)

slowQueries.forEach(log => {
  console.info(`慢查询 (${log.duration}ms): ${log.message}`)
})
```

### 监控缓存命中率

```typescript
const cache = QueryCache.getInstance()

setInterval(() => {
  const stats = cache.getStatistics()
  console.info(`缓存命中率: ${(stats.hitRate * 100).toFixed(2)}%`)
  console.info(`缓存大小: ${stats.size}/${stats.maxSize}`)
}, 60000)  // 每分钟输出一次
```

## 性能测试

```typescript
// 性能测试工具
class PerformanceTester {
  async testFindById(iterations: number = 100): Promise<void> {
    const times: number[] = []
    
    for (let i = 0; i < iterations; i++) {
      const start = Date.now()
      await repo.findById(1)
      times.push(Date.now() - start)
    }
    
    const avg = times.reduce((a, b) => a + b, 0) / times.length
    const max = Math.max(...times)
    const min = Math.min(...times)
    
    console.info(`findById 性能测试 (${iterations} 次)`)
    console.info(`平均: ${avg.toFixed(2)}ms`)
    console.info(`最大: ${max}ms`)
    console.info(`最小: ${min}ms`)
  }
  
  async testBatchInsert(count: number = 1000): Promise<void> {
    const users = generateTestUsers(count)
    
    const start = Date.now()
    await repo.batchInsert(users, new BatchInsertOptions())
    const duration = Date.now() - start
    
    console.info(`批量插入 ${count} 条数据`)
    console.info(`耗时: ${duration}ms`)
    console.info(`速度: ${(count / duration * 1000).toFixed(2)} 条/秒`)
  }
}
```

## 缓存键修复记录

### v2.1.19 缓存键冲突修复

OCORM 的 `QueryCache` 使用特殊分隔符（空字符 `\x00`）生成缓存键，确保实体名或 ID 中包含特殊字符时不会产生键冲突。

```typescript
// 缓存键格式: entityName\x00id
// 例如: User\x0012345
```

之前的版本使用 `:` 作为分隔符，如果实体名或 ID 中包含 `:` 可能会导致缓存键冲突。

## 下一步

- [日志系统](11-日志系统.md) - 使用日志分析性能
- [完整示例](16-完整示例.md) - 查看优化后的完整示例

