# 事务与批量操作

本章节介绍 OCORM 的事务管理和批量操作功能，包括基本事务、带有选项的事务以及高性能批量插入。

## 事务概述

事务（Transaction）是数据库操作的原子单元，确保一组操作要么全部成功，要么全部失败回滚。

## 基本事务

### 使用 transaction() 方法

```typescript
import { Repository } from 'ocorm'

const repo = new Repository('User')

// 基本事务示例
await repo.transaction(async (txRepo) => {
  // 在事务中，所有操作是原子的
  
  // 创建用户
  const user1 = EntityData.from('User', {
    name: '用户1',
    email: 'user1@example.com'
  })
  await txRepo.save(user1)
  
  // 创建另一个用户
  const user2 = EntityData.from('User', {
    name: '用户2',
    email: 'user2@example.com'
  })
  await txRepo.save(user2)
  
  // 如果任何操作失败，所有更改将自动回滚
})

console.info('事务执行成功')
```

### 事务中的 Repository

在事务回调中，你会收到一个特殊的 Repository 实例（txRepo），它与普通的 Repository 功能相同，但所有操作都在同一个事务中执行。

```typescript
await repo.transaction(async (txRepo) => {
  // txRepo 提供了所有 Repository 方法
  
  // 查询
  const user = await txRepo.findById(1)
  
  // 更新
  if (user) {
    user.setPropertyValue('balance', 1000)
    await txRepo.save(user)
  }
  
  // 删除
  await txRepo.removeById(2)
  
  // 使用查询构建器
  const users = await txRepo.createQueryBuilder()
    .where('status', ConditionOperator.EQUAL, 1)
    .getMany()
})
```

## 高级事务选项

### 带有重试的事务

当遇到临时性错误（如锁竞争）时，可以配置自动重试：

```typescript
import { TransactionOptions } from 'ocorm'

// 配置重试选项：最多重试 3 次，每次间隔 200ms
const options = TransactionOptions.withRetry(3, 200)

await repo.transactionWithOptions(async (txRepo) => {
  // 事务操作...
}, options)
```

### 带有超时的事务

为事务设置最大执行时间：

```typescript
// 设置 5 秒超时
const options = TransactionOptions.withTimeout(5000)

await repo.transactionWithOptions(async (txRepo) => {
  // 如果 5 秒内未完成，事务将自动回滚
}, options)
```

### 自定义事务选项

```typescript
import { TransactionOptions, IsolationLevel } from 'ocorm'

const options = TransactionOptions.fromConfig({
  isolation: IsolationLevel.SERIALIZABLE,  // 隔离级别
  timeout: 10000,                           // 超时时间（毫秒）
  retries: 2,                               // 重试次数
  retryDelay: 100,                          // 重试间隔（毫秒）
  readOnly: false                           // 是否只读事务
})

await repo.transactionWithOptions(async (txRepo) => {
  // 事务操作...
}, options)
```

### 事务隔离级别

| 隔离级别 | 说明 |
|---------|------|
| `IsolationLevel.READ_UNCOMMITTED` | 读未提交，可能出现脏读 |
| `IsolationLevel.READ_COMMITTED` | 读已提交 |
| `IsolationLevel.REPEATABLE_READ` | 可重复读 |
| `IsolationLevel.SERIALIZABLE` | 串行化，最高隔离级别 |

> **注意**：SQLite 仅支持 `READ_UNCOMMITTED` 的显式设置，其余隔离级别会回退为默认的 `READ_COMMITTED`。

### 只读事务

当 `readOnly = true` 时，OCORM 会启用数据库只读模式（SQLite `PRAGMA query_only=1`），用于阻止写入操作。
如果设置失败，事务会直接回滚并抛出错误。

```typescript
const options = TransactionOptions.fromConfig({
  readOnly: true,
  timeout: 5000
})

await repo.transactionWithOptions(async (txRepo) => {
  const users = await txRepo.createQueryBuilder()
    .where('status', ConditionOperator.EQUAL, 1)
    .getMany()
  console.info(users.length)
}, options)
```

## 批量操作

### 批量插入（batchInsert）

使用 `batchInsert` 高效插入大量数据：

```typescript
import { Repository, EntityData, BatchInsertOptions } from 'ocorm'

const repo = new Repository('User')

// 准备数据
const users: EntityData[] = []
for (let i = 0; i < 1000; i++) {
  users.push(EntityData.from('User', {
    name: `用户${i}`,
    email: `user${i}@example.com`,
    age: Math.floor(Math.random() * 100)
  }))
}

// 配置批量插入选项
const options = new BatchInsertOptions()
options.useTransaction = true    // 使用事务（推荐，保证原子性）
options.executeHooks = true      // 执行 beforeSave 钩子

// 执行批量插入
const result = await repo.batchInsert(users, options)

console.info(`成功插入: ${result.insertedCount}/${result.totalCount}`)
if (!result.success) {
  console.error(`失败信息: ${result.errorMessage}`)
}
```

### BatchInsertOptions 配置

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `useTransaction` | boolean | true | 是否使用事务 |
| `executeHooks` | boolean | true | 是否执行 beforeSave 钩子 |

### 批量插入性能对比

| 方式 | 1000 条数据 | 10000 条数据 |
|------|------------|-------------|
| 逐条 save() | ~5 秒 | ~50 秒 |
| saveAll() | ~4 秒 | ~40 秒 |
| batchInsert() | ~0.1 秒 | ~1 秒 |

> 注意：实际性能取决于设备性能和数据库配置。

### 批量更新

OCORM 没有专门的批量更新方法，可以使用循环 + 事务：

```typescript
async function batchUpdateAges(updates: Array<{id: number, age: number}>): Promise<void> {
  await repo.transaction(async (txRepo) => {
    for (const update of updates) {
      const user = await txRepo.findById(update.id)
      if (user) {
        user.setPropertyValue('age', update.age)
        await txRepo.save(user)
      }
    }
  })
}
```

### 批量删除

```typescript
async function batchDeleteByIds(ids: number[]): Promise<void> {
  await repo.transaction(async (txRepo) => {
    for (const id of ids) {
      await txRepo.removeById(id)
    }
  })
}
```

## 业务场景示例

### 转账事务

```typescript
// 转账服务
class TransferService {
  private userRepo: Repository
  
  constructor() {
    this.userRepo = new Repository('User')
  }
  
  // 转账操作
  async transfer(fromId: number, toId: number, amount: number): Promise<boolean> {
    try {
      await this.userRepo.transaction(async (txRepo) => {
        // 1. 查询转出账户
        const fromUser = await txRepo.findById(fromId)
        if (!fromUser) {
          throw new Error('转出账户不存在')
        }
        
        const balance = fromUser.getPropertyValue('balance') as number
        if (balance < amount) {
          throw new Error('余额不足')
        }
        
        // 2. 扣款
        fromUser.setPropertyValue('balance', balance - amount)
        await txRepo.save(fromUser)
        
        // 3. 查询转入账户
        const toUser = await txRepo.findById(toId)
        if (!toUser) {
          throw new Error('转入账户不存在')
        }
        
        // 4. 收款
        const toBalance = toUser.getPropertyValue('balance') as number
        toUser.setPropertyValue('balance', toBalance + amount)
        await txRepo.save(toUser)
        
        // 5. 记录交易日志
        // ...
      })
      
      console.info(`转账成功: ${fromId} -> ${toId}, 金额: ${amount}`)
      return true
    } catch (error) {
      console.error(`转账失败: ${error.message}`)
      return false
    }
  }
}
```

### 批量导入用户

```typescript
// 用户导入服务
class UserImportService {
  private userRepo: Repository
  private roleRepo: Repository
  
  constructor() {
    this.userRepo = new Repository('User')
    this.roleRepo = new Repository('Role')
  }
  
  // 批量导入用户
  async importUsers(userList: Array<{
    name: string
    email: string
    age: number
    roleIds: number[]
  }>): Promise<ImportResult> {
    const startTime = Date.now()
    let successCount = 0
    let failCount = 0
    const errors: string[] = []
    
    // 配置批量插入选项
    const batchOptions = new BatchInsertOptions()
    batchOptions.useTransaction = true
    batchOptions.executeHooks = true
    
    try {
      await this.userRepo.transaction(async (txRepo) => {
        for (let i = 0; i < userList.length; i++) {
          const userData = userList[i]
          
          try {
            // 检查邮箱是否已存在
            const existing = await txRepo.createQueryBuilder()
              .where('email', ConditionOperator.EQUAL, userData.email)
              .getOne()
            
            if (existing) {
              throw new Error('邮箱已存在')
            }
            
            // 创建用户
            const entityData = EntityData.from('User', {
              name: userData.name,
              email: userData.email,
              age: userData.age,
              status: 1,
              createdAt: Date.now()
            })
            
            await txRepo.save(entityData)
            
            // 分配角色
            if (userData.roleIds && userData.roleIds.length > 0) {
              await txRepo.attach(
                entityData.getPropertyValue('id') as number,
                userData.roleIds[0],
                'roles'
              )
            }
            
            successCount++
          } catch (error) {
            failCount++
            errors.push(`第 ${i + 1} 行: ${error.message}`)
          }
        }
      })
      
      const duration = Date.now() - startTime
      
      return {
        successCount,
        failCount,
        totalCount: userList.length,
        errors,
        duration
      }
    } catch (error) {
      return {
        successCount,
        failCount,
        totalCount: userList.length,
        errors: [...errors, `事务失败: ${error.message}`],
        duration
      }
    }
  }
}

interface ImportResult {
  successCount: number
  failCount: number
  totalCount: number
  errors: string[]
  duration: number
}
```

## 注意事项

### 事务中的限制

在事务中请注意：
1. **避免长时间运行的操作**：事务会锁定数据库，长时间事务会影响性能
2. **避免嵌套事务**：OCORM 不支持嵌套事务
3. **注意死锁**：多个事务访问相同数据时可能产生死锁

### 批量插入注意事项

1. **数据验证**：在批量插入前进行数据验证
2. **内存管理**：大量数据时考虑分批处理
3. **唯一约束**：注意唯一约束冲突

```typescript
// 分批处理大量数据
async function importLargeDataset(data: Array<any>): Promise<void> {
  const BATCH_SIZE = 500
  const repo = new Repository('User')
  
  for (let i = 0; i < data.length; i += BATCH_SIZE) {
    const batch = data.slice(i, i + BATCH_SIZE)
    const entities = batch.map(item => EntityData.from('User', item))
    
    await repo.batchInsert(entities, new BatchInsertOptions())
    
    console.info(`进度: ${Math.min(i + BATCH_SIZE, data.length)}/${data.length}`)
  }
}
```

## 下一步

- [生命周期钩子](08-生命周期钩子.md) - 在事务中嵌入业务逻辑
- [性能优化](13-性能优化.md) - 优化批量操作性能




