# 批量操作

OCORM 提供高性能的批量操作 API，适用于大量数据的导入和处理场景。

---

## batchInsert - 批量插入

使用 `RdbStore.batchInsert` API 实现高性能批量插入，比逐条插入效率更高。

### 基本用法

```typescript
import { Repository, EntityData } from '@offlinecat/ocorm'

const userRepo = new Repository('User')

// 准备批量插入的数据
const users: EntityData[] = []
for (let i = 0; i < 1000; i++) {
  const user = new EntityData('User')
  user.addProperty('name', `用户${i}`, 'string')
  user.addProperty('email', `user${i}@example.com`, 'string')
  user.addProperty('age', 20 + (i % 50), 'number')
  users.push(user)
}

// 执行批量插入
const result = await userRepo.batchInsert(users)

if (result.success) {
  console.log(`成功插入 ${result.insertedCount} 条记录`)
} else {
  console.log(`插入失败: ${result.errorMessage}`)
}
```

---

## BatchInsertOptions - 批量插入选项

通过 `BatchInsertOptions` 可以控制批量插入的行为。

### 选项属性

```typescript
class BatchInsertOptions {
  useTransaction: boolean      // 是否在事务中执行，默认 true
  executeHooks: boolean        // 是否执行 beforeSave 钩子，默认 true
  executeValidation: boolean   // 是否执行数据验证，默认 true
}
```

### 使用自定义选项

```typescript
import { Repository, BatchInsertOptions } from '@offlinecat/ocorm'

const userRepo = new Repository('User')

// 方式1：直接构造
const options = new BatchInsertOptions(true, true, true)

// 方式2：使用静态方法
const options2 = BatchInsertOptions.create(true, false, true)

const result = await userRepo.batchInsert(users, options)
```

### 预设选项

```typescript
// 默认选项：使用事务、执行钩子、执行验证
const defaultOptions = BatchInsertOptions.createDefault()

// 快速插入：不使用事务、不执行钩子、不验证
// 适用于大量数据快速导入，但需自行保证数据正确性
const fastOptions = BatchInsertOptions.createFast()

// 安全插入：使用事务、执行钩子、执行验证
const safeOptions = BatchInsertOptions.createSafe()
```

### 选项场景建议

| 场景 | useTransaction | executeHooks | executeValidation |
|------|----------------|--------------|-------------------|
| 常规批量插入 | ✓ | ✓ | ✓ |
| 大数据量快速导入 | ✗ | ✗ | ✗ |
| 需要触发业务逻辑 | ✓ | ✓ | ✓ |
| 数据已验证过 | ✓ | ✗ | ✗ |

---

## BatchInsertResult - 批量插入结果

批量插入返回 `BatchInsertResult` 对象。

### 结构

```typescript
class BatchInsertResult {
  success: boolean           // 是否全部成功（全部成功才为 true）
  insertedCount: number      // 成功插入数量
  totalCount: number         // 总数量（部分场景可能为 0，建议以传入数组长度作为兜底）
  failedIndexes: number[]    // 失败的索引（仅在可定位到具体失败记录时返回；部分成功时通常为空）
  errorMessage: string       // 错误信息
}
```

### 使用示例

```typescript
const result = await userRepo.batchInsert(users)
const total = result.totalCount > 0 ? result.totalCount : users.length

console.log(`是否全部成功: ${result.success}`)
console.log(`插入数量: ${result.insertedCount}/${total}`)

if (!result.success) {
  console.log(`错误信息: ${result.errorMessage}`)
  if (result.failedIndexes.length > 0) {
    console.log(`失败索引: ${result.failedIndexes.join(', ')}`)
  }
}
```

### 部分成功处理

```typescript
const result = await userRepo.batchInsert(users)
const total = result.totalCount > 0 ? result.totalCount : users.length

if (result.success) {
  console.log('全部插入成功')
} else if (result.insertedCount > 0) {
  // 部分成功
  console.log(`部分成功: ${result.insertedCount}/${total}`)
} else {
  // 全部失败
  console.log(`全部失败: ${result.errorMessage}`)
}
```

---

## saveAll - 批量保存

`saveAll` 方法逐条执行 `save`，支持插入和更新混合操作。

```typescript
const userRepo = new Repository('User')

const users: EntityData[] = []

// 新用户（无主键，将执行 INSERT）
const newUser = new EntityData('User')
newUser.addProperty('name', '新用户', 'string')
users.push(newUser)

// 已有用户（有主键，将执行 UPDATE）
const existingUser = new EntityData('User')
existingUser.addProperty('id', 1, 'number')
existingUser.addProperty('name', '更新的名字', 'string')
users.push(existingUser)

// 批量保存（返回每条记录的结果）
const results = await userRepo.saveAll(users)

for (let i = 0; i < results.length; i++) {
  if (results[i].success) {
    console.log(`第 ${i + 1} 条保存成功`)
  } else {
    console.log(`第 ${i + 1} 条保存失败: ${results[i].errorMessage}`)
  }
}
```

### batchInsert vs saveAll

| 特性 | batchInsert | saveAll |
|------|-------------|---------|
| 操作类型 | 仅 INSERT | INSERT 或 UPDATE |
| 性能 | 高（批量 API） | 较低（逐条执行） |
| 事务支持 | 可选 | 无（需手动包装） |
| 钩子执行 | 可选 | 始终执行 |
| 返回值 | 汇总结果 | 逐条结果 |
| 适用场景 | 大量新数据导入 | 混合保存操作 |

---

## 事务中的批量操作

### 在事务中批量插入

```typescript
const userRepo = new Repository('User')

await userRepo.transaction(async (txRepo) => {
  // 在事务中执行批量插入
  const users: EntityData[] = []
  for (let i = 0; i < 100; i++) {
    const user = new EntityData('User')
    user.addProperty('name', `用户${i}`, 'string')
    users.push(user)
  }
  
  // 使用不带事务的选项（外部已有事务）
  const options = BatchInsertOptions.create(false, true, true)
  const result = await txRepo.batchInsert(users, options)
  
  if (!result.success) {
    throw new Error(result.errorMessage)  // 触发事务回滚
  }
})
```

### 批量保存 + 事务

```typescript
await userRepo.transaction(async (txRepo) => {
  const results = await txRepo.saveAll(users)
  
  // 检查是否有失败
  const failed = results.filter(r => !r.success)
  if (failed.length > 0) {
    throw new Error('批量保存存在失败记录')
  }
})
```

---

## 性能优化建议

### 1. 合理设置批次大小

```typescript
async function batchInsertInChunks(
  repo: Repository,
  allData: EntityData[],
  chunkSize: number = 500
) {
  const chunks: EntityData[][] = []
  for (let i = 0; i < allData.length; i += chunkSize) {
    chunks.push(allData.slice(i, i + chunkSize))
  }
  
  let totalInserted = 0
  for (const chunk of chunks) {
    const result = await repo.batchInsert(chunk)
    totalInserted += result.insertedCount
  }
  
  return totalInserted
}
```

### 2. 大数据量使用快速模式

```typescript
// 导入 10000 条数据
const largeData: EntityData[] = prepareLargeData()

// 使用快速模式
const result = await userRepo.batchInsert(
  largeData,
  BatchInsertOptions.createFast()
)
```

### 3. 数据预验证

```typescript
// 先验证数据
const validData: EntityData[] = []
const invalidIndexes: number[] = []

for (let i = 0; i < allData.length; i++) {
  if (isValidData(allData[i])) {
    validData.push(allData[i])
  } else {
    invalidIndexes.push(i)
  }
}

// 再批量插入（跳过验证）
const options = BatchInsertOptions.create(true, false, false)
const result = await userRepo.batchInsert(validData, options)
```

---

## 完整示例

### 数据导入场景

```typescript
import { Repository, EntityData, BatchInsertOptions } from '@offlinecat/ocorm'

async function importUsers(csvData: string[][]) {
  const userRepo = new Repository('User')
  const users: EntityData[] = []
  
  // 解析数据
  for (const row of csvData) {
    const user = new EntityData('User')
    user.addProperty('name', row[0], 'string')
    user.addProperty('email', row[1], 'string')
    user.addProperty('age', parseInt(row[2]), 'number')
    users.push(user)
  }
  
  // 批量插入
  const result = await userRepo.batchInsert(users)
  
  return {
    success: result.success,
    imported: result.insertedCount,
    total: users.length,
    message: result.success 
      ? `成功导入 ${result.insertedCount} 条记录`
      : `导入失败: ${result.errorMessage}`
  }
}
```

### 带进度回调的批量插入

```typescript
async function batchInsertWithProgress(
  repo: Repository,
  data: EntityData[],
  onProgress: (current: number, total: number) => void
) {
  const chunkSize = 100
  const total = data.length
  let processed = 0
  let insertedCount = 0
  
  for (let i = 0; i < total; i += chunkSize) {
    const chunk = data.slice(i, Math.min(i + chunkSize, total))
    const result = await repo.batchInsert(chunk)
    
    insertedCount += result.insertedCount
    processed += chunk.length
    
    onProgress(processed, total)
  }
  
  return { insertedCount, totalCount: total }
}

// 使用
await batchInsertWithProgress(userRepo, users, (current, total) => {
  console.log(`进度: ${current}/${total} (${Math.round(current/total*100)}%)`)
})
```

