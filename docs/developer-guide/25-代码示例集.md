# 代码示例集

本文档提供 OCORM 常见场景的完整代码示例。

---

## 基础 CRUD

### 完整的实体定义与 CRUD

```typescript
import { 
  defineEntity, 
  Repository, 
  EntityData, 
  ColumnType,
  OCORMInit,
  DatabaseConfig
} from '@aspect/ocorm'

// 1. 定义实体
defineEntity('User', {
  tableName: 'users',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT, nullable: false },
    { property: 'email', type: ColumnType.TEXT, unique: true },
    { property: 'age', type: ColumnType.INTEGER },
    { property: 'isActive', name: 'is_active', type: ColumnType.INTEGER },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER },
    { property: 'updatedAt', name: 'updated_at', type: ColumnType.INTEGER }
  ]
})

// 2. 初始化 ORM（在应用启动时调用一次）
async function init(context: Context): Promise<void> {
  await OCORMInit(context, {
    config: new DatabaseConfig('myapp.db')
  })
}

// 3. 创建 Repository
const userRepo = new Repository('User')

// 4. 创建（插入）
async function createUser(name: string, email: string, age: number): Promise<number> {
  const user = new EntityData('User')
  user.addProperty('name', name, 'string')
  user.addProperty('email', email, 'string')
  user.addProperty('age', age, 'number')
  user.addProperty('isActive', true, 'boolean')
  user.addProperty('createdAt', Date.now(), 'number')
  user.addProperty('updatedAt', Date.now(), 'number')
  
  const result = await userRepo.save(user)
  if (result.success) {
    console.log(`用户创建成功，ID: ${result.insertId}`)
    return result.insertId
  } else {
    throw new Error(result.errorMessage)
  }
}

// 5. 读取（查询）
async function getUser(id: number): Promise<EntityData | null> {
  return await userRepo.findById(id)
}

async function getAllUsers(): Promise<Array<EntityData>> {
  return await userRepo.findAll()
}

// 6. 更新
async function updateUser(id: number, name: string): Promise<void> {
  const user = await userRepo.findById(id)
  if (user === null) {
    throw new Error('用户不存在')
  }
  
  user.addProperty('name', name, 'string')
  user.addProperty('updatedAt', Date.now(), 'number')
  
  const result = await userRepo.save(user)
  if (!result.success) {
    throw new Error(result.errorMessage)
  }
}

// 7. 删除
async function deleteUser(id: number): Promise<void> {
  const result = await userRepo.removeById(id)
  if (!result.success) {
    throw new Error(result.errorMessage)
  }
}

// 使用示例
async function demo(): Promise<void> {
  // 创建用户
  const userId = await createUser('张三', 'zhangsan@example.com', 25)
  
  // 查询用户
  const user = await getUser(userId)
  console.log('用户信息:', user?.getPropertyValue('name'))
  
  // 更新用户
  await updateUser(userId, '张三（已修改）')
  
  // 查询所有用户
  const users = await getAllUsers()
  console.log('用户总数:', users.length)
  
  // 删除用户
  await deleteUser(userId)
}
```

---

## 复杂查询

### 条件查询

```typescript
import { QueryBuilder, QueryExecutor, ConditionOperator } from '@aspect/ocorm'

const userRepo = new Repository('User')

// 单条件查询
async function findActiveUsers(): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .where('isActive', ConditionOperator.EQUAL, true)
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}

// 多条件查询（AND）
async function findActiveAdults(): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .where('isActive', ConditionOperator.EQUAL, true)
    .andWhere('age', ConditionOperator.GREATER_EQUAL, 18)
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}

// 多条件查询（OR）
async function findSpecialUsers(): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .where('age', ConditionOperator.GREATER, 60)
    .orWhere('isActive', ConditionOperator.EQUAL, false)
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}

// 范围查询
async function findUsersByAgeRange(minAge: number, maxAge: number): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .whereBetween('age', minAge, maxAge)
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}

// 模糊查询
async function searchUsersByName(keyword: string): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .whereLike('name', `%${keyword}%`)
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}

// IN 查询
async function findUsersByIds(ids: Array<number>): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .whereIn('id', ids)
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}

// NULL 查询
async function findUsersWithoutEmail(): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .whereNull('email')
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}
```

### 排序与分页

```typescript
// 排序查询
async function findUsersSortedByAge(): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .orderBy('age', 'DESC')
    .orderBy('name', 'ASC')
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}

// 限制数量
async function findTopUsers(limit: number): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .orderBy('createdAt', 'DESC')
    .limit(limit)
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}

// 分页查询（使用 QueryBuilder）
async function findUsersPaginated(page: number, pageSize: number): Promise<PaginatedResult> {
  const qb = userRepo.createQueryBuilder()
    .orderBy('id', 'ASC')
    .paginate(page, pageSize)
  
  const executor = new QueryExecutor(qb)
  return await executor.getPaginated()
}

// 分页查询（使用 Repository）
async function findUsersPaginatedSimple(page: number, pageSize: number): Promise<PaginatedResult> {
  return await userRepo.findPaginated(page, pageSize)
}

// 分页结果处理
async function displayPaginatedUsers(): Promise<void> {
  const result = await userRepo.findPaginated(1, 10)
  
  console.log(`第 ${result.page} 页，共 ${result.totalPages} 页`)
  console.log(`总记录数: ${result.total}`)
  console.log(`当前页数据量: ${result.getCurrentPageSize()}`)
  
  if (result.hasNextPage()) {
    console.log('还有下一页')
  }
  
  for (const user of result.data) {
    console.log(`- ${user.getPropertyValue('name')}`)
  }
}
```

### 选择特定列

```typescript
// 只查询特定列
async function findUserNames(): Promise<Array<EntityData>> {
  const qb = userRepo.createQueryBuilder()
    .select(['id', 'name'])
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}

// 统计数量
async function countActiveUsers(): Promise<number> {
  const qb = userRepo.createQueryBuilder()
    .where('isActive', ConditionOperator.EQUAL, true)
  
  const executor = new QueryExecutor(qb)
  return await executor.count()
}

// 获取单条记录
async function findFirstActiveUser(): Promise<EntityData | null> {
  const qb = userRepo.createQueryBuilder()
    .where('isActive', ConditionOperator.EQUAL, true)
    .orderBy('createdAt', 'ASC')
    .limit(1)
  
  const executor = new QueryExecutor(qb)
  return await executor.getOne()
}
```

---

## 关联操作

### 一对一关系

```typescript
import { 
  defineEntity, 
  MetadataStorage, 
  RelationMetadata, 
  RelationType,
  ColumnType 
} from '@aspect/ocorm'

// 定义实体
defineEntity('User', {
  tableName: 'users',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT }
  ]
})

defineEntity('Profile', {
  tableName: 'profiles',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'userId', name: 'user_id', type: ColumnType.INTEGER },
    { property: 'bio', type: ColumnType.TEXT },
    { property: 'avatar', type: ColumnType.TEXT }
  ]
})

// 注册关系
const storage = MetadataStorage.getInstance()

// User.profile -> Profile（外键在 Profile 表）
storage.registerRelation('User', new RelationMetadata(
  RelationType.ONE_TO_ONE,
  'User',
  'Profile',
  'profile',
  'user_id',
  'target'  // 外键在目标表
))

// Profile.user -> User（外键在本表）
storage.registerRelation('Profile', new RelationMetadata(
  RelationType.ONE_TO_ONE,
  'Profile',
  'User',
  'user',
  'user_id',
  'source'  // 外键在源表
))

// 查询用户及其资料
async function getUserWithProfile(userId: number): Promise<EntityData | null> {
  const qb = new Repository('User').createQueryBuilder()
    .where('id', ConditionOperator.EQUAL, userId)
    .with('profile')  // 预加载关联
  
  const executor = new QueryExecutor(qb)
  const users = await executor.get()
  
  if (users.length === 0) return null
  
  const user = users[0]
  const profile = user.getRelatedValue('profile')
  
  console.log('用户:', user.getPropertyValue('name'))
  console.log('简介:', profile?.singleEntity?.getPropertyValue('bio'))
  
  return user
}
```

### 一对多关系

```typescript
import { 
  defineEntity, 
  MetadataStorage, 
  RelationMetadata, 
  RelationType,
  ColumnType 
} from '@aspect/ocorm'

// 定义实体
defineEntity('User', {
  tableName: 'users',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT }
  ]
})

defineEntity('Post', {
  tableName: 'posts',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'userId', name: 'user_id', type: ColumnType.INTEGER },
    { property: 'title', type: ColumnType.TEXT },
    { property: 'content', type: ColumnType.TEXT }
  ]
})

// 注册关系
const storage = MetadataStorage.getInstance()

// User.posts -> Post[]（一对多）
storage.registerRelation('User', new RelationMetadata(
  RelationType.ONE_TO_MANY,
  'User',
  'Post',
  'posts',
  'user_id'
))

// Post.author -> User（多对一）
storage.registerRelation('Post', new RelationMetadata(
  RelationType.MANY_TO_ONE,
  'Post',
  'User',
  'author',
  'user_id'
))

// 查询用户及其所有文章
async function getUserWithPosts(userId: number): Promise<void> {
  const qb = new Repository('User').createQueryBuilder()
    .where('id', ConditionOperator.EQUAL, userId)
    .with('posts')
  
  const executor = new QueryExecutor(qb)
  const users = await executor.get()
  
  if (users.length === 0) return
  
  const user = users[0]
  const postsRelation = user.getRelatedValue('posts')
  
  console.log('用户:', user.getPropertyValue('name'))
  console.log('文章数:', postsRelation?.entityArray.length)
  
  if (postsRelation?.isArray) {
    for (const post of postsRelation.entityArray) {
      console.log(`- ${post.getPropertyValue('title')}`)
    }
  }
}

// 查询文章及其作者
async function getPostWithAuthor(postId: number): Promise<void> {
  const qb = new Repository('Post').createQueryBuilder()
    .where('id', ConditionOperator.EQUAL, postId)
    .with('author')
  
  const executor = new QueryExecutor(qb)
  const posts = await executor.get()
  
  if (posts.length === 0) return
  
  const post = posts[0]
  const authorRelation = post.getRelatedValue('author')
  
  console.log('文章:', post.getPropertyValue('title'))
  console.log('作者:', authorRelation?.singleEntity?.getPropertyValue('name'))
}
```

### 多对多关系

```typescript
import { defineEntity, MetadataStorage, ColumnType } from '@aspect/ocorm'

// 定义实体
defineEntity('Article', {
  tableName: 'articles',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'title', type: ColumnType.TEXT }
  ]
})

defineEntity('Tag', {
  tableName: 'tags',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT }
  ]
})

// 注册多对多关系
const storage = MetadataStorage.getInstance()
storage.registerManyToMany(
  'Article',      // 源实体
  'Tag',          // 目标实体
  'tags',         // 属性名
  'article_tags', // 中间表
  'article_id',   // 源实体外键
  'tag_id'        // 目标实体外键
)

const articleRepo = new Repository('Article')

// 建立关联
async function addTagToArticle(articleId: number, tagId: number): Promise<void> {
  await articleRepo.attach(articleId, tagId, 'tags')
}

// 解除关联
async function removeTagFromArticle(articleId: number, tagId: number): Promise<void> {
  await articleRepo.detach(articleId, tagId, 'tags')
}

// 同步关联（替换所有标签）
async function setArticleTags(articleId: number, tagIds: Array<number>): Promise<void> {
  await articleRepo.sync(articleId, tagIds, 'tags')
}

// 查询文章及其标签
async function getArticleWithTags(articleId: number): Promise<void> {
  const qb = articleRepo.createQueryBuilder()
    .where('id', ConditionOperator.EQUAL, articleId)
    .with('tags')
  
  const executor = new QueryExecutor(qb)
  const articles = await executor.get()
  
  if (articles.length === 0) return
  
  const article = articles[0]
  const tagsRelation = article.getRelatedValue('tags')
  
  console.log('文章:', article.getPropertyValue('title'))
  if (tagsRelation?.isArray) {
    const tagNames = tagsRelation.entityArray.map(t => t.getPropertyValue('name'))
    console.log('标签:', tagNames.join(', '))
  }
}
```

---

## 事务示例

### 基础事务

```typescript
const userRepo = new Repository('User')

// 基础事务
async function transferPoints(fromUserId: number, toUserId: number, points: number): Promise<void> {
  await userRepo.transaction(async (repo) => {
    // 获取两个用户
    const fromUser = await repo.findById(fromUserId)
    const toUser = await repo.findById(toUserId)
    
    if (fromUser === null || toUser === null) {
      throw new Error('用户不存在')
    }
    
    const fromPoints = fromUser.getPropertyValue('points') as number
    if (fromPoints < points) {
      throw new Error('积分不足')  // 抛出异常会自动回滚
    }
    
    // 扣除积分
    fromUser.addProperty('points', fromPoints - points, 'number')
    await repo.save(fromUser)
    
    // 增加积分
    const toPoints = toUser.getPropertyValue('points') as number
    toUser.addProperty('points', toPoints + points, 'number')
    await repo.save(toUser)
    
    // 事务成功，自动提交
  })
}
```

### 带选项的事务

```typescript
import { TransactionOptions, IsolationLevel } from '@aspect/ocorm'

// 带超时和重试的事务
async function reliableOperation(): Promise<void> {
  const options = TransactionOptions.fromConfig({
    timeout: 10000,      // 10 秒超时
    retries: 3,          // 失败重试 3 次
    retryDelay: 500,     // 重试间隔 500ms
    isolation: IsolationLevel.SERIALIZABLE  // 最高隔离级别
  })
  
  await userRepo.transactionWithOptions(async (repo) => {
    // 关键业务操作
    const user = await repo.findById(1)
    if (user) {
      user.addProperty('balance', 100, 'number')
      await repo.save(user)
    }
  }, options)
}

// 只读事务
async function readOnlyQuery(): Promise<void> {
  const options = TransactionOptions.readOnly()
  
  await userRepo.transactionWithOptions(async (repo) => {
    // 只读操作
    const users = await repo.findAll()
    console.log('用户数:', users.length)
    
    // 写操作会失败
    // await repo.save(newUser)  // Error!
  }, options)
}
```

### 嵌套操作示例

```typescript
// 创建用户及其资料（事务）
async function createUserWithProfile(
  name: string, 
  email: string, 
  bio: string
): Promise<number> {
  let userId = 0
  
  await userRepo.transaction(async (repo) => {
    // 创建用户
    const user = new EntityData('User')
    user.addProperty('name', name, 'string')
    user.addProperty('email', email, 'string')
    user.addProperty('createdAt', Date.now(), 'number')
    
    const userResult = await repo.save(user)
    if (!userResult.success) {
      throw new Error(userResult.errorMessage)
    }
    userId = userResult.insertId
    
    // 创建资料
    const profileRepo = new Repository('Profile')
    const profile = new EntityData('Profile')
    profile.addProperty('userId', userId, 'number')
    profile.addProperty('bio', bio, 'string')
    
    const profileResult = await profileRepo.save(profile)
    if (!profileResult.success) {
      throw new Error(profileResult.errorMessage)
    }
    
    // 两个操作都成功，事务提交
  })
  
  return userId
}
```

---

## ViewModel 映射

### EntityData 转 ViewModel

```typescript
import { ViewModelMapper, EntityData } from '@aspect/ocorm'

// 定义 ViewModel 类
class UserViewModel {
  id: number = 0
  name: string = ''
  email: string = ''
  displayName: string = ''
}

// 转换单个实体
function toUserViewModel(entityData: EntityData): UserViewModel {
  return ViewModelMapper.toViewModel<UserViewModel>(
    entityData,
    () => new UserViewModel(),  // 工厂函数
    (data, vm) => {             // 映射函数
      vm.id = data.getPropertyValue('id') as number
      vm.name = data.getPropertyValue('name') as string
      vm.email = data.getPropertyValue('email') as string
      vm.displayName = `${vm.name} <${vm.email}>`
    }
  )
}

// 批量转换
function toUserViewModelArray(entities: Array<EntityData>): Array<UserViewModel> {
  return ViewModelMapper.toViewModelArray<UserViewModel>(
    entities,
    () => new UserViewModel(),
    (data, vm) => {
      vm.id = data.getPropertyValue('id') as number
      vm.name = data.getPropertyValue('name') as string
      vm.email = data.getPropertyValue('email') as string
      vm.displayName = `${vm.name} <${vm.email}>`
    }
  )
}

// 使用示例
async function displayUsers(): Promise<void> {
  const users = await userRepo.findAll()
  const viewModels = toUserViewModelArray(users)
  
  for (const vm of viewModels) {
    console.log(vm.displayName)
  }
}
```

### ViewModel 转 EntityData

```typescript
// ViewModel 转 EntityData
function toEntityData(vm: UserViewModel): EntityData {
  return ViewModelMapper.toEntityData<UserViewModel>(
    vm,
    'User',
    ['id', 'name', 'email'],  // 属性列表
    (viewModel, propertyName) => {  // 值获取函数
      switch (propertyName) {
        case 'id': return viewModel.id
        case 'name': return viewModel.name
        case 'email': return viewModel.email
        default: return null
      }
    }
  )
}

// 使用示例
async function updateFromViewModel(vm: UserViewModel): Promise<void> {
  const entityData = toEntityData(vm)
  await userRepo.save(entityData)
}
```

---

## 批量操作

### 批量插入

```typescript
import { BatchInsertOptions } from '@aspect/ocorm'

// 批量创建用户
async function createUsersInBatch(count: number): Promise<void> {
  const users: Array<EntityData> = []
  
  for (let i = 0; i < count; i++) {
    const user = new EntityData('User')
    user.addProperty('name', `用户${i + 1}`, 'string')
    user.addProperty('email', `user${i + 1}@example.com`, 'string')
    user.addProperty('age', 20 + (i % 30), 'number')
    user.addProperty('createdAt', Date.now(), 'number')
    users.push(user)
  }
  
  // 默认选项（使用事务，执行钩子和验证）
  const result = await userRepo.batchInsert(users)
  
  console.log(`成功: ${result.success}`)
  console.log(`插入: ${result.insertedCount}/${result.totalCount}`)
  
  if (!result.success) {
    console.error('错误:', result.errorMessage)
  }
}

// 快速批量插入（跳过钩子和验证）
async function fastBatchInsert(users: Array<EntityData>): Promise<void> {
  const options = BatchInsertOptions.createFast()
  const result = await userRepo.batchInsert(users, options)
  
  console.log(`快速插入完成: ${result.insertedCount} 条`)
}

// 自定义批量插入选项
async function customBatchInsert(users: Array<EntityData>): Promise<void> {
  const options = new BatchInsertOptions()
  options.useTransaction = true
  options.executeHooks = false      // 跳过钩子
  options.executeValidation = true  // 执行验证
  
  const result = await userRepo.batchInsert(users, options)
  console.log(`插入结果: ${result.success}`)
}
```

---

## 软删除操作

```typescript
// 定义支持软删除的实体
defineEntity('Article', {
  tableName: 'articles',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'title', type: ColumnType.TEXT },
    { property: 'deletedAt', name: 'deleted_at', type: ColumnType.INTEGER }
  ],
  softDelete: true  // 自动使用 deleted_at 列
})

const articleRepo = new Repository('Article')

// 软删除
async function softDeleteArticle(id: number): Promise<void> {
  await articleRepo.removeById(id)  // 设置 deleted_at
  console.log('文章已软删除')
}

// 强制物理删除
async function forceDeleteArticle(id: number): Promise<void> {
  await articleRepo.forceRemoveById(id)  // 真正删除
  console.log('文章已永久删除')
}

// 恢复软删除
async function restoreArticle(id: number): Promise<void> {
  await articleRepo.restore(id)  // 清除 deleted_at
  console.log('文章已恢复')
}

// 查询（默认排除已删除）
async function getActiveArticles(): Promise<Array<EntityData>> {
  return await articleRepo.findAll()  // 不包含已删除
}

// 查询（包含已删除）
async function getAllArticles(): Promise<Array<EntityData>> {
  return await articleRepo.findAll(true)  // 包含已删除
}

// 仅查询已删除的文章
async function getDeletedArticles(): Promise<Array<EntityData>> {
  const qb = articleRepo.createQueryBuilder()
    .onlyDeleted()
  
  const executor = new QueryExecutor(qb)
  return await executor.get()
}
```

---

## 数据验证

```typescript
import { 
  ValidationMetadataStorage, 
  EntityValidator, 
  ValidationError 
} from '@aspect/ocorm'

// 注册验证规则
const validationStorage = ValidationMetadataStorage.getInstance()

// name 字段验证
validationStorage.registerRule('User', 'name', { type: 'required' })
validationStorage.registerRule('User', 'name', { type: 'length', min: 2, max: 50 })

// email 字段验证
validationStorage.registerRule('User', 'email', { type: 'required' })
validationStorage.registerRule('User', 'email', { type: 'email' })

// age 字段验证
validationStorage.registerRule('User', 'age', { type: 'required' })

// 手动验证
function validateUser(userData: EntityData): boolean {
  const result = EntityValidator.validate('User', userData)
  
  if (!result.isValid()) {
    console.error('验证失败:')
    for (const error of result.errors) {
      console.error(`- ${error.message}`)
    }
    return false
  }
  
  return true
}

// 保存时自动验证
async function saveUserWithValidation(userData: EntityData): Promise<void> {
  try {
    await userRepo.save(userData)  // 自动验证
    console.log('保存成功')
  } catch (error) {
    if (error instanceof ValidationError) {
      console.error('验证失败:', error.message)
    } else {
      throw error
    }
  }
}
```

---

## 生命周期钩子

```typescript
import { MetadataStorage, EntityHooks, EntityData } from '@aspect/ocorm'

// 定义钩子回调函数
const userHooks = new EntityHooks(
  // beforeSave
  async (data: EntityData) => {
    console.log('即将保存用户:', data.getPropertyValue('name'))
    
    // 自动设置更新时间
    data.addProperty('updatedAt', Date.now(), 'number')
    
    // 如果是新记录，设置创建时间
    if (!data.hasProperty('id') || data.getPropertyValue('id') === null) {
      data.addProperty('createdAt', Date.now(), 'number')
    }
  },
  // afterLoad
  async (data: EntityData) => {
    console.log('用户已加载:', data.getPropertyValue('name'))
    
    // 可以添加计算属性
    const age = data.getPropertyValue('age') as number
    data.setTransient('isAdult', age >= 18)
  },
  // beforeDelete
  async (data: EntityData) => {
    console.log('即将删除用户:', data.getPropertyValue('name'))
    
    // 可以执行清理逻辑
    // 例如：删除关联数据、记录日志等
  }
)

// 注册钩子到实体元数据
const metadata = MetadataStorage.getInstance().getEntityMetadata('User')
if (metadata) {
  metadata.setHooks(userHooks)
}

// 使用钩子
async function demoHooks(): Promise<void> {
  const user = new EntityData('User')
  user.addProperty('name', '测试用户', 'string')
  user.addProperty('age', 25, 'number')
  
  // 保存时触发 beforeSave
  await userRepo.save(user)
  
  // 查询时触发 afterLoad
  const loaded = await userRepo.findById(user.getPropertyValue('id') as number)
  console.log('是否成年:', loaded?.getTransient('isAdult'))
  
  // 删除时触发 beforeDelete
  await userRepo.remove(loaded!)
}
```

---

## 日志与调试

```typescript
import { Logger, LogLevel, QueryCache } from '@aspect/ocorm'

// 配置日志
const logger = Logger.getInstance()
logger.configure(true, LogLevel.DEBUG)

// 启用日志历史记录
logger.setRecordHistory(true)

// 执行一些操作
async function debugDemo(): Promise<void> {
  const userRepo = new Repository('User')
  
  // 执行查询
  await userRepo.findAll()
  await userRepo.findById(1)
  
  // 获取日志历史
  const history = logger.getLogHistory()
  console.log('=== SQL 执行日志 ===')
  for (const log of history) {
    console.log(log)
  }
  
  // 查看缓存统计
  const cache = QueryCache.getInstance()
  const stats = cache.getStatistics()
  console.log('=== 缓存统计 ===')
  console.log(`命中: ${stats.hits}`)
  console.log(`未命中: ${stats.misses}`)
  console.log(`命中率: ${(stats.hitRate * 100).toFixed(2)}%`)
  
  // 清理
  logger.clearLogHistory()
}
```
