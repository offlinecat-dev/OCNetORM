# 多对多关系

多对多关系（Many-to-Many）表示两个实体之间可以相互关联多个对象，如文章与标签、学生与课程等。多对多关系需要通过中间表来实现。

---

## 关系定义

### ManyToManyMetadata 创建

OCORM 使用 `ManyToManyMetadata` 类来定义多对多关系，它继承自 `RelationMetadata` 并包含中间表配置：

```typescript
import { ManyToManyMetadata, MetadataStorage } from '@aspect/ocorm'

// 定义 Post <-> Tag 多对多关系
const postToTags = new ManyToManyMetadata(
  'Post',           // 源实体名称
  'Tag',            // 目标实体名称
  'tags',           // 源实体中的属性名
  'post_tags',      // 中间表名
  'post_id',        // 源实体在中间表的外键列名
  'tag_id'          // 目标实体在中间表的外键列名
)

// 注册关系
MetadataStorage.getInstance().registerRelation('Post', postToTags)
```

### 双向关系

如果需要从两个方向都能导航，需要定义两个关系：

```typescript
const storage = MetadataStorage.getInstance()

// Post.tags -> Tag[]
storage.registerRelation('Post', new ManyToManyMetadata(
  'Post',
  'Tag',
  'tags',
  'post_tags',
  'post_id',
  'tag_id'
))

// Tag.posts -> Post[]（反向）
storage.registerRelation('Tag', new ManyToManyMetadata(
  'Tag',
  'Post',
  'posts',
  'post_tags',
  'tag_id',    // 注意：反向关系的外键顺序相反
  'post_id'
))
```

---

## 中间表配置

### 中间表结构

多对多关系的中间表通常包含两个外键列，分别指向两个关联实体的主键：

```sql
CREATE TABLE IF NOT EXISTS post_tags (
  post_id INTEGER NOT NULL,
  tag_id INTEGER NOT NULL,
  PRIMARY KEY (post_id, tag_id),
  FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
  FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
)
```

### 中间表创建辅助函数

```typescript
// 获取中间表创建 SQL
function getPostTagJoinTableSQL(): string {
  return `
    CREATE TABLE IF NOT EXISTS post_tags (
      post_id INTEGER NOT NULL,
      tag_id INTEGER NOT NULL,
      PRIMARY KEY (post_id, tag_id),
      FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
      FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
    )
  `
}
```

---

## 实体定义示例

### Post 实体

```typescript
import { defineEntity, ColumnType } from '@aspect/ocorm'

defineEntity('Post', {
  tableName: 'posts',
  columns: [
    { property: 'id', primaryKey: true, autoIncrement: true },
    { property: 'title', type: ColumnType.TEXT, nullable: false },
    { property: 'content', type: ColumnType.TEXT },
    { property: 'userId', name: 'user_id', type: ColumnType.INTEGER },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER }
  ]
})
```

### Tag 实体

```typescript
defineEntity('Tag', {
  tableName: 'tags',
  columns: [
    { property: 'id', primaryKey: true, autoIncrement: true },
    { property: 'name', type: ColumnType.TEXT, nullable: false, unique: true },
    { property: 'color', type: ColumnType.TEXT }
  ]
})
```

### 注册多对多关系

```typescript
import { ManyToManyMetadata, MetadataStorage } from '@aspect/ocorm'

function registerPostTagRelations(): void {
  const storage = MetadataStorage.getInstance()
  
  // Post.tags -> Tag[]
  storage.registerRelation('Post', new ManyToManyMetadata(
    'Post',
    'Tag',
    'tags',
    'post_tags',
    'post_id',
    'tag_id'
  ))
  
  // Tag.posts -> Post[]
  storage.registerRelation('Tag', new ManyToManyMetadata(
    'Tag',
    'Post',
    'posts',
    'post_tags',
    'tag_id',
    'post_id'
  ))
}
```

---

## 关联查询

### 查询文章并加载标签

```typescript
import { QueryBuilder, QueryExecutor, ConditionOperator } from '@aspect/ocorm'

// 查询文章并预加载标签
const qb = new QueryBuilder('Post')
  .where('id', ConditionOperator.EQUAL, 1)
  .with('tags')

const post = await new QueryExecutor(qb).first()

if (post !== null) {
  // 获取关联的标签列表
  const tags = post.getRelations('tags')  // 返回 EntityData[]
  
  console.log(`文章 "${post.getPropertyValue('title')}" 有 ${tags.length} 个标签:`)
  for (const tag of tags) {
    console.log(`- ${tag.getPropertyValue('name')}`)
  }
}
```

### 查询标签并加载文章

```typescript
// 查询标签并预加载相关文章
const qb = new QueryBuilder('Tag')
  .where('name', ConditionOperator.EQUAL, 'TypeScript')
  .with('posts')

const tag = await new QueryExecutor(qb).first()

if (tag !== null) {
  const posts = tag.getRelations('posts')
  console.log(`标签 "${tag.getPropertyValue('name')}" 下有 ${posts.length} 篇文章`)
}
```

### 批量查询预加载

```typescript
// 查询所有文章并预加载各自的标签
const qb = new QueryBuilder('Post')
  .with('tags')
  .orderBy('createdAt', 'DESC')
  .limit(20)

const posts = await new QueryExecutor(qb).get()

for (const post of posts) {
  const tags = post.getRelations('tags')
  const tagNames = tags.map(t => t.getPropertyValue('name')).join(', ')
  console.log(`${post.getPropertyValue('title')} [${tagNames}]`)
}
```

---

## 关联数据操作

### 添加关联

多对多关系的关联通过直接操作中间表实现：

```typescript
import { DatabaseManager } from '@aspect/ocorm'

// 为文章添加标签
async function addTagToPost(postId: number, tagId: number): Promise<void> {
  const store = DatabaseManager.getInstance().getStore()
  
  await store.insert('post_tags', {
    post_id: postId,
    tag_id: tagId
  })
}

// 批量添加标签
async function addTagsToPost(postId: number, tagIds: number[]): Promise<void> {
  const store = DatabaseManager.getInstance().getStore()
  
  for (const tagId of tagIds) {
    await store.insert('post_tags', {
      post_id: postId,
      tag_id: tagId
    })
  }
}
```

### 移除关联

```typescript
import { relationalStore } from '@kit.ArkData'

// 移除文章的某个标签
async function removeTagFromPost(postId: number, tagId: number): Promise<void> {
  const store = DatabaseManager.getInstance().getStore()
  
  const predicates = new relationalStore.RdbPredicates('post_tags')
  predicates.equalTo('post_id', postId)
  predicates.and()
  predicates.equalTo('tag_id', tagId)
  
  await store.delete(predicates)
}

// 移除文章的所有标签
async function removeAllTagsFromPost(postId: number): Promise<void> {
  const store = DatabaseManager.getInstance().getStore()
  
  const predicates = new relationalStore.RdbPredicates('post_tags')
  predicates.equalTo('post_id', postId)
  
  await store.delete(predicates)
}
```

### 替换关联

```typescript
// 替换文章的所有标签
async function replacePostTags(postId: number, newTagIds: number[]): Promise<void> {
  const store = DatabaseManager.getInstance().getStore()
  
  // 1. 删除现有关联
  const deletePredicates = new relationalStore.RdbPredicates('post_tags')
  deletePredicates.equalTo('post_id', postId)
  await store.delete(deletePredicates)
  
  // 2. 添加新关联
  for (const tagId of newTagIds) {
    await store.insert('post_tags', {
      post_id: postId,
      tag_id: tagId
    })
  }
}
```

---

## 完整示例

### 博客标签系统

```typescript
import {
  defineEntity,
  ColumnType,
  Repository,
  EntityData,
  MetadataStorage,
  ManyToManyMetadata,
  QueryBuilder,
  QueryExecutor,
  ConditionOperator,
  DatabaseManager
} from '@aspect/ocorm'

// 1. 定义实体
defineEntity('Post', {
  tableName: 'posts',
  columns: [
    { property: 'id', primaryKey: true, autoIncrement: true },
    { property: 'title', type: ColumnType.TEXT, nullable: false },
    { property: 'content', type: ColumnType.TEXT },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER }
  ]
})

defineEntity('Tag', {
  tableName: 'tags',
  columns: [
    { property: 'id', primaryKey: true, autoIncrement: true },
    { property: 'name', type: ColumnType.TEXT, nullable: false, unique: true },
    { property: 'color', type: ColumnType.TEXT }
  ]
})

// 2. 注册多对多关系
const storage = MetadataStorage.getInstance()

storage.registerRelation('Post', new ManyToManyMetadata(
  'Post', 'Tag', 'tags', 'post_tags', 'post_id', 'tag_id'
))

storage.registerRelation('Tag', new ManyToManyMetadata(
  'Tag', 'Post', 'posts', 'post_tags', 'tag_id', 'post_id'
))

// 3. 服务函数

// 创建文章并添加标签
async function createPostWithTags(
  title: string,
  content: string,
  tagIds: number[]
): Promise<number> {
  const postRepo = new Repository('Post')
  const store = DatabaseManager.getInstance().getStore()
  
  // 创建文章
  const post = new EntityData('Post')
  post.addProperty('title', title, 'string')
  post.addProperty('content', content, 'string')
  post.addProperty('createdAt', Date.now(), 'number')
  
  const result = await postRepo.save(post)
  const postId = result.insertId
  
  // 添加标签关联
  for (const tagId of tagIds) {
    await store.insert('post_tags', {
      post_id: postId,
      tag_id: tagId
    })
  }
  
  return postId
}

// 获取文章及其标签
async function getPostWithTags(postId: number): Promise<EntityData | null> {
  const qb = new QueryBuilder('Post')
    .where('id', ConditionOperator.EQUAL, postId)
    .with('tags')
  
  return await new QueryExecutor(qb).first()
}

// 获取某标签下的所有文章
async function getPostsByTag(tagName: string): Promise<EntityData[]> {
  // 先查询标签
  const tagQb = new QueryBuilder('Tag')
    .where('name', ConditionOperator.EQUAL, tagName)
    .with('posts')
  
  const tag = await new QueryExecutor(tagQb).first()
  
  if (tag === null) {
    return []
  }
  
  return tag.getRelations('posts')
}

// 获取热门标签（按文章数量）
async function getPopularTags(limit: number): Promise<EntityData[]> {
  const qb = new QueryBuilder('Tag')
    .with('posts')
  
  const tags = await new QueryExecutor(qb).get()
  
  // 按关联文章数量排序
  const sortedTags = tags.sort((a, b) => {
    const countA = a.getRelations('posts').length
    const countB = b.getRelations('posts').length
    return countB - countA
  })
  
  return sortedTags.slice(0, limit)
}

// 4. 使用示例
async function example() {
  const tagRepo = new Repository('Tag')
  
  // 创建标签
  const tag1 = new EntityData('Tag')
  tag1.addProperty('name', 'TypeScript', 'string')
  tag1.addProperty('color', '#3178c6', 'string')
  const tagResult1 = await tagRepo.save(tag1)
  
  const tag2 = new EntityData('Tag')
  tag2.addProperty('name', 'HarmonyOS', 'string')
  tag2.addProperty('color', '#0052d9', 'string')
  const tagResult2 = await tagRepo.save(tag2)
  
  // 创建带标签的文章
  const postId = await createPostWithTags(
    'OCORM 使用指南',
    '这是一篇关于 OCORM 的教程...',
    [tagResult1.insertId, tagResult2.insertId]
  )
  
  // 查询文章及标签
  const post = await getPostWithTags(postId)
  if (post !== null) {
    const tags = post.getRelations('tags')
    console.log(`文章: ${post.getPropertyValue('title')}`)
    console.log(`标签: ${tags.map(t => t.getPropertyValue('name')).join(', ')}`)
  }
  
  // 查询标签下的文章
  const tsPosts = await getPostsByTag('TypeScript')
  console.log(`TypeScript 标签下有 ${tsPosts.length} 篇文章`)
}
```

---

## ManyToManyMetadata API

### 构造函数参数

| 参数 | 类型 | 说明 |
|------|------|------|
| `sourceEntity` | string | 源实体名称 |
| `targetEntity` | string | 目标实体名称 |
| `propertyName` | string | 在源实体中的属性名 |
| `joinTable` | string | 中间表名 |
| `joinSourceKey` | string | 源实体在中间表的外键列名 |
| `joinTargetKey` | string | 目标实体在中间表的外键列名 |

### 属性

| 属性 | 类型 | 说明 |
|------|------|------|
| `type` | RelationType | 固定为 `MANY_TO_MANY` |
| `joinTable` | string | 中间表名 |
| `joinSourceKey` | string | 源外键列名 |
| `joinTargetKey` | string | 目标外键列名 |

---

## 注意事项

1. **中间表管理**：OCORM 不会自动创建中间表，需要手动创建或在 Schema 同步时处理
2. **外键顺序**：定义反向关系时，注意 `joinSourceKey` 和 `joinTargetKey` 的顺序需要对调
3. **级联删除**：建议在中间表的外键上设置 `ON DELETE CASCADE`，确保删除实体时自动清理关联
4. **查询性能**：多对多关系使用两次查询策略（先查中间表，再查目标表），注意数据量大时的性能
5. **数据一致性**：关联操作建议在事务中执行，确保数据一致性
6. **唯一约束**：中间表建议使用复合主键或唯一索引，防止重复关联
