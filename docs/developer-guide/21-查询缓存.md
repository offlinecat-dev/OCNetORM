# 查询缓存

OCORM 提供简单高效的一级查询缓存机制，减少重复查询，提升数据库访问性能。

---

## 基本概念

查询缓存是一种内存缓存机制，用于存储实体查询结果。当相同的查询再次执行时，直接从缓存返回数据，避免重复的数据库访问。

**核心特性**：
- **单例模式**：全局唯一的缓存实例
- **TTL 过期**：支持缓存条目自动过期
- **LRU 驱逐**：当缓存满时，自动驱逐最旧的条目
- **深拷贝**：缓存数据与应用数据隔离，避免相互污染
- **统计信息**：提供命中率等统计数据

---

## QueryCache 类

### 获取实例

```typescript
import { QueryCache } from '@aspect/ocorm'

// 获取 QueryCache 单例实例
const cache = QueryCache.getInstance()
```

### 配置缓存

```typescript
import { QueryCache, QueryCacheConfig } from '@aspect/ocorm'

const cache = QueryCache.getInstance()

// 配置缓存选项
cache.configure({
  maxSize: 200,      // 最大缓存条目数，默认 100
  ttlMs: 120000,     // 缓存生存时间（毫秒），默认 60000（1分钟）
  enabled: true      // 是否启用缓存，默认 true
})

// 也可以单独配置某个选项
cache.configure({ maxSize: 500 })
cache.configure({ ttlMs: 300000 })  // 5 分钟
```

### 启用/禁用缓存

```typescript
const cache = QueryCache.getInstance()

// 禁用缓存
cache.disable()

// 启用缓存
cache.enable()

// 检查缓存状态
if (cache.isEnabled()) {
  console.log('缓存已启用')
}
```

---

## 缓存操作

### 设置缓存

```typescript
import { QueryCache, EntityData } from '@aspect/ocorm'

const cache = QueryCache.getInstance()

// 创建实体数据
const userData = new EntityData('User')
userData.addProperty('id', 1, 'number')
userData.addProperty('name', '张三', 'string')

// 设置缓存（entityName, id, data）
cache.set('User', 1, userData)

// 支持字符串类型的 ID
cache.set('User', 'uuid-123', userData)
```

### 获取缓存

```typescript
const cache = QueryCache.getInstance()

// 获取缓存数据
const cachedUser = cache.get('User', 1)

if (cachedUser !== null) {
  console.log('缓存命中:', cachedUser.getPropertyValue('name'))
} else {
  console.log('缓存未命中，需要查询数据库')
}
```

> **注意**：`get` 方法返回的是数据的深拷贝，修改返回的数据不会影响缓存中的原始数据。

### 使缓存失效

```typescript
const cache = QueryCache.getInstance()

// 使单条记录缓存失效
cache.invalidate('User', 1)

// 使某实体的所有缓存失效
cache.invalidateEntity('User')

// 清空所有缓存
cache.clear()
```

---

## 缓存统计

```typescript
import { QueryCache, CacheStatistics } from '@aspect/ocorm'

const cache = QueryCache.getInstance()

// 获取缓存统计信息
const stats: CacheStatistics = cache.getStatistics()

console.log(`缓存命中次数: ${stats.hits}`)
console.log(`缓存未命中次数: ${stats.misses}`)
console.log(`当前缓存条目数: ${stats.size}`)
console.log(`缓存命中率: ${(stats.hitRate * 100).toFixed(2)}%`)

// 获取当前缓存大小
const size = cache.getSize()
```

### CacheStatistics 结构

```typescript
interface CacheStatistics {
  hits: number      // 缓存命中次数
  misses: number    // 缓存未命中次数
  size: number      // 当前缓存条目数
  hitRate: number   // 命中率（0-1）
}
```

---

## 与 Repository 集成

Repository 默认集成了查询缓存，`findById` 方法会自动使用缓存。

### 自动缓存

```typescript
const userRepo = new Repository('User')

// 第一次查询：从数据库读取，并缓存结果
const user1 = await userRepo.findById(1)

// 第二次查询：直接从缓存返回
const user2 = await userRepo.findById(1)
```

### 禁用缓存查询

```typescript
// findById(id, includeDeleted, useCache)
// 第三个参数 useCache 控制是否使用缓存

// 禁用缓存，强制从数据库读取
const freshUser = await userRepo.findById(1, false, false)
```

### 自动缓存失效

Repository 的写操作会自动使相关缓存失效：

```typescript
const userRepo = new Repository('User')

// 保存操作 → 自动使该实体缓存失效
await userRepo.save(userData)

// 删除操作 → 自动使该记录缓存失效
await userRepo.removeById(1)

// 批量插入 → 自动使该实体所有缓存失效
await userRepo.batchInsert(users)
```

---

## 缓存策略

### TTL 过期策略

缓存条目在指定时间后自动过期：

```typescript
const cache = QueryCache.getInstance()

// 设置 30 秒过期
cache.configure({ ttlMs: 30000 })

cache.set('User', 1, userData)

// 30 秒后，该缓存自动失效
// get 返回 null，并自动删除过期条目
```

### LRU 驱逐策略

当缓存条目数达到 `maxSize` 时，自动驱逐最旧的条目：

```typescript
const cache = QueryCache.getInstance()

// 设置最大缓存 2 条
cache.configure({ maxSize: 2 })

cache.set('User', 1, user1)  // 缓存: [1]
cache.set('User', 2, user2)  // 缓存: [1, 2]
cache.set('User', 3, user3)  // 缓存: [2, 3]，user1 被驱逐

cache.get('User', 1)  // null
cache.get('User', 2)  // user2
cache.get('User', 3)  // user3
```

---

## 深拷贝机制

缓存使用深拷贝机制保护数据完整性：

```typescript
const cache = QueryCache.getInstance()

const userData = new EntityData('User')
userData.addProperty('name', 'Original', 'string')

// 存入缓存（存储的是深拷贝）
cache.set('User', 1, userData)

// 修改原始数据
userData.addProperty('name', 'Modified', 'string')

// 从缓存获取（返回的也是深拷贝）
const cached = cache.get('User', 1)
console.log(cached?.getPropertyValue('name'))  // 'Original'，不受影响
```

深拷贝包含：
- 所有属性值
- 临时数据（transient）
- 关联数据（related）

---

## 配置建议

### 开发环境

```typescript
// 开发环境：短 TTL，便于调试
cache.configure({
  maxSize: 50,
  ttlMs: 10000,   // 10 秒
  enabled: true
})
```

### 生产环境

```typescript
// 生产环境：较大缓存，较长 TTL
cache.configure({
  maxSize: 500,
  ttlMs: 300000,  // 5 分钟
  enabled: true
})
```

### 高并发场景

```typescript
// 高并发读取场景：增大缓存容量
cache.configure({
  maxSize: 1000,
  ttlMs: 60000,   // 1 分钟
  enabled: true
})
```

### 数据实时性要求高

```typescript
// 实时性要求高：短 TTL 或禁用缓存
cache.configure({
  ttlMs: 5000,    // 5 秒
  enabled: true
})

// 或直接禁用
cache.disable()
```

---

## 注意事项

1. **缓存一致性**：写操作会自动使缓存失效，但多实例部署时需注意缓存同步
2. **内存占用**：合理设置 `maxSize`，避免内存占用过大
3. **软删除**：包含已删除数据的查询不会使用缓存
4. **关联查询**：仅缓存主实体数据，关联数据需单独处理
5. **测试环境**：测试前建议调用 `QueryCache.resetInstance()` 重置缓存状态

---

## 完整示例

```typescript
import { Repository, EntityData, QueryCache } from '@aspect/ocorm'

// 1. 配置全局缓存
const cache = QueryCache.getInstance()
cache.configure({
  maxSize: 200,
  ttlMs: 60000,
  enabled: true
})

// 2. 使用 Repository（自动集成缓存）
const userRepo = new Repository('User')

// 第一次查询（缓存未命中，查询数据库）
const user = await userRepo.findById(1)
console.log('第一次查询完成')

// 第二次查询（缓存命中，直接返回）
const userCached = await userRepo.findById(1)
console.log('第二次查询完成（从缓存）')

// 查看统计
const stats = cache.getStatistics()
console.log(`命中率: ${(stats.hitRate * 100).toFixed(2)}%`)

// 更新数据（自动使缓存失效）
user?.addProperty('name', '新名字', 'string')
if (user) {
  await userRepo.save(user)
}

// 再次查询（缓存已失效，重新查询数据库）
const updatedUser = await userRepo.findById(1)

// 手动清空缓存
cache.clear()
```
