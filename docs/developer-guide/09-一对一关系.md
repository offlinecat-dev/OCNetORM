# 一对一关系

一对一关系（One-to-One）表示两个实体之间的单向或双向一一对应关系，如用户与用户资料、订单与发票等。

---

## 关系定义

### RelationMetadata 创建

```typescript
import { RelationMetadata, RelationType, MetadataStorage } from '@aspect/ocorm'

// 定义 User -> Profile 一对一关系
// 外键 userId 在 Profile 表中
const userToProfile = new RelationMetadata(
  RelationType.ONE_TO_ONE,  // 关系类型
  'User',                   // 源实体
  'Profile',                // 目标实体
  'profile',                // 源实体中的属性名
  'userId',                 // 外键列名
  'target'                  // 外键位置：'target' 表示外键在目标表
)

// 注册关系
MetadataStorage.getInstance().addRelation(userToProfile)
```

### 外键位置说明

一对一关系需要指定外键所在的位置：

```typescript
// 外键在目标表（Profile.userId -> User.id）
// User 是主表，Profile 是从表
new RelationMetadata(
  RelationType.ONE_TO_ONE,
  'User',
  'Profile',
  'profile',
  'userId',
  'target'  // 外键在 Profile 表
)

// 外键在源表（Profile.userId -> User.id）
// Profile 是主表，User 是从表
new RelationMetadata(
  RelationType.ONE_TO_ONE,
  'Profile',
  'User',
  'user',
  'userId',
  'source'  // 外键在 Profile 表
)
```

### 双向关系

如果需要双向导航，需要定义两个关系：

```typescript
// User -> Profile
MetadataStorage.getInstance().addRelation(new RelationMetadata(
  RelationType.ONE_TO_ONE,
  'User',
  'Profile',
  'profile',
  'userId',
  'target'
))

// Profile -> User（反向）
MetadataStorage.getInstance().addRelation(new RelationMetadata(
  RelationType.ONE_TO_ONE,
  'Profile',
  'User',
  'user',
  'userId',
  'source'
))
```

---

## 实体定义示例

### User 实体

```typescript
import { defineEntity, ColumnType } from '@aspect/ocorm'

defineEntity('User', {
  tableName: 'users',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT },
    { property: 'email', type: ColumnType.TEXT, unique: true }
  ]
})
```

### Profile 实体

```typescript
defineEntity('Profile', {
  tableName: 'profiles',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'userId', name: 'user_id', type: ColumnType.INTEGER },
    { property: 'avatar', type: ColumnType.TEXT },
    { property: 'bio', type: ColumnType.TEXT },
    { property: 'birthday', type: ColumnType.INTEGER }
  ]
})
```

### 注册关系

```typescript
import { MetadataStorage, RelationMetadata, RelationType } from '@aspect/ocorm'

function registerUserProfileRelation() {
  const storage = MetadataStorage.getInstance()
  
  // User.profile -> Profile
  storage.addRelation(new RelationMetadata(
    RelationType.ONE_TO_ONE,
    'User',
    'Profile',
    'profile',
    'userId',
    'target'
  ))
}
```

---

## 关联查询

### 使用 with 预加载

```typescript
import { QueryBuilder, QueryExecutor } from '@aspect/ocorm'

// 查询用户并加载其资料
const qb = new QueryBuilder('User')
  .where('id', ConditionOperator.EQUAL, 1)
  .with('profile')  // 预加载 profile 关联

const executor = new QueryExecutor(qb)
const user = await executor.first()

if (user !== null) {
  // 访问关联数据
  const profile = user.getRelation('profile')
  if (profile !== null) {
    console.log(profile.getPropertyValue('avatar'))
    console.log(profile.getPropertyValue('bio'))
  }
}
```

### 延迟加载

```typescript
const qb = new QueryBuilder('User')
  .where('id', ConditionOperator.EQUAL, 1)
  .withLazy('profile')  // 延迟加载

const user = await new QueryExecutor(qb).first()

// 需要时再加载关联
// （延迟加载在访问关联属性时自动触发）
```

### 批量查询预加载

```typescript
// 查询所有用户并预加载资料
const qb = new QueryBuilder('User')
  .with('profile')
  .orderBy('createdAt', 'DESC')

const users = await new QueryExecutor(qb).get()

for (const user of users) {
  const profile = user.getRelation('profile')
  console.log(`${user.getPropertyValue('name')}: ${profile?.getPropertyValue('bio')}`)
}
```

---

## 级联操作

### 级联配置

```typescript
import { CascadeOptions } from '@aspect/ocorm'

// 完全级联（插入、更新、删除都级联）
const fullCascade = new RelationMetadata(
  RelationType.ONE_TO_ONE,
  'User',
  'Profile',
  'profile',
  'userId',
  'target',
  true  // 启用全部级联
)

// 部分级联
const cascadeOptions: CascadeOptions = {
  insert: true,   // 级联插入
  update: true,   // 级联更新
  remove: false   // 不级联删除
}

const partialCascade = new RelationMetadata(
  RelationType.ONE_TO_ONE,
  'User',
  'Profile',
  'profile',
  'userId',
  'target',
  cascadeOptions
)
```

### 级联保存示例

```typescript
const userRepo = new Repository('User')
const profileRepo = new Repository('Profile')

// 先创建用户
const user = new EntityData('User')
user.addProperty('name', '张三', 'string')
user.addProperty('email', 'zhangsan@example.com', 'string')

const userResult = await userRepo.save(user)

// 再创建资料，关联到用户
const profile = new EntityData('Profile')
profile.addProperty('userId', userResult.insertId, 'number')
profile.addProperty('avatar', '/avatars/zhangsan.png', 'string')
profile.addProperty('bio', '热爱编程', 'string')

await profileRepo.save(profile)
```

---

## CascadeOptions

级联选项控制关联实体的自动操作：

```typescript
interface CascadeOptions {
  insert?: boolean   // 保存主实体时，自动插入关联实体
  update?: boolean   // 更新主实体时，自动更新关联实体
  remove?: boolean   // 删除主实体时，自动删除关联实体
}
```

### 使用场景

| 场景 | insert | update | remove |
|------|--------|--------|--------|
| 完整生命周期管理 | ✓ | ✓ | ✓ |
| 仅同步创建 | ✓ | ✗ | ✗ |
| 保留历史记录 | ✓ | ✓ | ✗ |
| 独立管理 | ✗ | ✗ | ✗ |

---

## 完整示例

### 用户与资料管理

```typescript
import {
  defineEntity,
  ColumnType,
  Repository,
  EntityData,
  MetadataStorage,
  RelationMetadata,
  RelationType,
  QueryBuilder,
  QueryExecutor,
  ConditionOperator
} from '@aspect/ocorm'

// 1. 定义实体
defineEntity('User', {
  tableName: 'users',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT },
    { property: 'email', type: ColumnType.TEXT, unique: true },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER }
  ]
})

defineEntity('Profile', {
  tableName: 'profiles',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'userId', name: 'user_id', type: ColumnType.INTEGER },
    { property: 'avatar', type: ColumnType.TEXT },
    { property: 'bio', type: ColumnType.TEXT },
    { property: 'website', type: ColumnType.TEXT }
  ]
})

// 2. 注册关系
MetadataStorage.getInstance().addRelation(new RelationMetadata(
  RelationType.ONE_TO_ONE,
  'User',
  'Profile',
  'profile',
  'userId',
  'target',
  { insert: true, update: true, remove: false }
))

// 3. 创建用户和资料
async function createUserWithProfile(
  name: string,
  email: string,
  bio: string
) {
  const userRepo = new Repository('User')
  const profileRepo = new Repository('Profile')
  
  // 创建用户
  const user = new EntityData('User')
  user.addProperty('name', name, 'string')
  user.addProperty('email', email, 'string')
  user.addProperty('createdAt', Date.now(), 'number')
  
  const userResult = await userRepo.save(user)
  
  // 创建资料
  const profile = new EntityData('Profile')
  profile.addProperty('userId', userResult.insertId, 'number')
  profile.addProperty('bio', bio, 'string')
  
  await profileRepo.save(profile)
  
  return userResult.insertId
}

// 4. 查询用户及其资料
async function getUserWithProfile(userId: number) {
  const qb = new QueryBuilder('User')
    .where('id', ConditionOperator.EQUAL, userId)
    .with('profile')
  
  return await new QueryExecutor(qb).first()
}

// 5. 更新用户资料
async function updateUserProfile(userId: number, bio: string, avatar: string) {
  const profileRepo = new Repository('Profile')
  
  // 查询现有资料
  const qb = new QueryBuilder('Profile')
    .where('userId', ConditionOperator.EQUAL, userId)
  
  const profile = await new QueryExecutor(qb).first()
  
  if (profile !== null) {
    profile.setPropertyValue('bio', bio)
    profile.setPropertyValue('avatar', avatar)
    await profileRepo.save(profile)
  }
}

// 使用示例
async function example() {
  // 创建
  const userId = await createUserWithProfile(
    '张三',
    'zhangsan@example.com',
    '全栈开发工程师'
  )
  
  // 查询
  const user = await getUserWithProfile(userId)
  if (user !== null) {
    console.log(`用户: ${user.getPropertyValue('name')}`)
    const profile = user.getRelation('profile')
    if (profile !== null) {
      console.log(`简介: ${profile.getPropertyValue('bio')}`)
    }
  }
  
  // 更新
  await updateUserProfile(userId, '资深全栈工程师', '/avatars/new.png')
}
```

---

## 注意事项

1. **外键位置**：一对一关系必须明确指定外键在哪个表中（`source` 或 `target`）
2. **唯一约束**：外键列建议添加唯一约束，确保一对一的完整性
3. **关联查询性能**：使用 `with` 预加载可以减少 N+1 查询问题
4. **级联删除谨慎**：生产环境中级联删除需要谨慎使用，避免误删数据
5. **空值处理**：关联实体可能为 null，访问前需要进行检查
