# 一对多关系

一对多关系（One-to-Many）表示一个实体可以关联多个其他实体，如用户与文章、分类与商品等。

---

## 关系定义

### ONE_TO_MANY 关系

一对多关系中，"一"方持有"多"方的集合引用。

```typescript
import { RelationMetadata, RelationType, MetadataStorage } from '@aspect/ocorm'

// 定义 User -> Posts 一对多关系
// 一个用户有多篇文章
const userToPosts = new RelationMetadata(
  RelationType.ONE_TO_MANY,  // 关系类型
  'User',                    // 源实体（"一"方）
  'Post',                    // 目标实体（"多"方）
  'posts',                   // 源实体中的属性名
  'userId'                   // 目标实体中的外键列名
)

// 注册关系
MetadataStorage.getInstance().registerRelation('User', userToPosts)
```

### MANY_TO_ONE 关系（反向）

从"多"方角度定义的反向关系：

```typescript
// 定义 Post -> User 多对一关系
// 每篇文章属于一个用户
const postToUser = new RelationMetadata(
  RelationType.MANY_TO_ONE,  // 关系类型
  'Post',                    // 源实体（"多"方）
  'User',                    // 目标实体（"一"方）
  'author',                  // 源实体中的属性名
  'userId'                   // 源实体中的外键列名
)

MetadataStorage.getInstance().registerRelation('Post', postToUser)
```

### 双向关系

完整的双向关系需要同时定义两个方向：

```typescript
const storage = MetadataStorage.getInstance()

// User.posts -> Post[]（一对多）
storage.registerRelation('User', new RelationMetadata(
  RelationType.ONE_TO_MANY,
  'User',
  'Post',
  'posts',
  'userId'
))

// Post.author -> User（多对一）
storage.registerRelation('Post', new RelationMetadata(
  RelationType.MANY_TO_ONE,
  'Post',
  'User',
  'author',
  'userId'
))
```

---

## 实体定义示例

### User 实体（"一"方）

```typescript
import { defineEntity, ColumnType } from '@aspect/ocorm'

defineEntity('User', {
  tableName: 'users',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT },
    { property: 'email', type: ColumnType.TEXT, unique: true },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER }
  ]
})
```

### Post 实体（"多"方）

```typescript
defineEntity('Post', {
  tableName: 'posts',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'userId', name: 'user_id', type: ColumnType.INTEGER },  // 外键
    { property: 'title', type: ColumnType.TEXT },
    { property: 'content', type: ColumnType.TEXT },
    { property: 'status', type: ColumnType.TEXT },
    { property: 'viewCount', name: 'view_count', type: ColumnType.INTEGER },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER }
  ]
})
```

---

## 关联查询

### 查询"一"方并加载"多"方

```typescript
import { QueryBuilder, QueryExecutor, ConditionOperator } from '@aspect/ocorm'

// 查询用户并加载其所有文章
const qb = new QueryBuilder('User')
  .where('id', ConditionOperator.EQUAL, 1)
  .with('posts')  // 预加载 posts 关联

const user = await new QueryExecutor(qb).getOne()

if (user !== null) {
  // 获取关联的文章列表
  const posts = user.getRelatedArray('posts')  // 返回 EntityData[]
  
  console.log(`用户 ${user.getPropertyValue('name')} 有 ${posts.length} 篇文章`)
  
  for (const post of posts) {
    console.log(`- ${post.getPropertyValue('title')}`)
  }
}
```

### 查询"多"方并加载"一"方

```typescript
// 查询文章并加载作者
const qb = new QueryBuilder('Post')
  .where('status', ConditionOperator.EQUAL, 'published')
  .with('author')  // 预加载作者
  .orderBy('createdAt', 'DESC')
  .limit(10)

const posts = await new QueryExecutor(qb).get()

for (const post of posts) {
  const author = post.getRelatedSingle('author')
  console.log(`${post.getPropertyValue('title')} - 作者: ${author?.getPropertyValue('name')}`)
}
```

### 批量预加载

```typescript
// 查询所有用户并预加载各自的文章
const qb = new QueryBuilder('User')
  .with('posts')
  .orderBy('createdAt', 'DESC')

const users = await new QueryExecutor(qb).get()

for (const user of users) {
  const posts = user.getRelatedArray('posts')
  console.log(`${user.getPropertyValue('name')}: ${posts.length} 篇文章`)
}
```

### 延迟加载

```typescript
const qb = new QueryBuilder('User')
  .where('id', ConditionOperator.EQUAL, 1)
  .withLazy('posts')  // 延迟加载

const user = await new QueryExecutor(qb).getOne()

// 需要时再加载关联（显式触发）
if (user !== null) {
  const posts = await user.loadRelatedArray('posts')
}
```

---

## 条件关联查询

### whereExists - 基于关联过滤

查询有特定条件关联数据的主实体：

```typescript
// 查询有已发布文章的用户
const qb = new QueryBuilder('User')
  .whereExists('posts', (subQuery) => {
    subQuery.where('status', ConditionOperator.EQUAL, 'published')
  })

const usersWithPosts = await new QueryExecutor(qb).get()
```

### 复杂关联条件

```typescript
// 查询有高浏览量文章的用户
const qb = new QueryBuilder('User')
  .whereExists('posts', (subQuery) => {
    subQuery
      .where('status', ConditionOperator.EQUAL, 'published')
      .andWhere('viewCount', ConditionOperator.GREATER, 1000)
  })
  .orderBy('createdAt', 'DESC')

const popularAuthors = await new QueryExecutor(qb).get()
```

---

## 级联操作

### CascadeOptions 配置

```typescript
import { CascadeOptions } from '@aspect/ocorm'

// 完全级联
const userToPosts = new RelationMetadata(
  RelationType.ONE_TO_MANY,
  'User',
  'Post',
  'posts',
  'userId',
  'source',
  true  // 启用全部级联
)

// 部分级联
const cascadeOptions: CascadeOptions = {
  insert: true,   // 级联插入：保存用户时自动保存新文章
  update: true,   // 级联更新：更新用户时自动更新文章
  remove: false   // 不级联删除：删除用户时不删除文章
}

const userToPostsPartial = new RelationMetadata(
  RelationType.ONE_TO_MANY,
  'User',
  'Post',
  'posts',
  'userId',
  'source',
  cascadeOptions
)
```

### 级联选项说明

| 选项 | 说明 | 使用场景 |
|------|------|----------|
| `insert: true` | 保存主实体时，自动保存新的关联实体 | 批量创建 |
| `update: true` | 更新主实体时，自动更新关联实体 | 数据同步 |
| `remove: true` | 删除主实体时，自动删除关联实体 | 完全清理 |

### 手动级联保存

不使用自动级联时的手动处理：

```typescript
const userRepo = new Repository('User')
const postRepo = new Repository('Post')

// 在事务中保存用户和文章
await userRepo.transaction(async (txRepo) => {
  // 1. 保存用户
  const user = new EntityData('User')
  user.addProperty('name', '作者', 'string')
  const userResult = await txRepo.save(user)
  
  // 2. 保存文章（手动设置外键）
  const post1 = new EntityData('Post')
  post1.addProperty('userId', userResult.insertId, 'number')
  post1.addProperty('title', '第一篇文章', 'string')
  
  const post2 = new EntityData('Post')
  post2.addProperty('userId', userResult.insertId, 'number')
  post2.addProperty('title', '第二篇文章', 'string')
  
  await postRepo.save(post1)
  await postRepo.save(post2)
})
```

---

## 关联数据操作

### 添加关联

```typescript
const userRepo = new Repository('User')
const postRepo = new Repository('Post')

// 查询用户
const user = await userRepo.findById(1)

// 创建新文章并关联到用户
const post = new EntityData('Post')
post.addProperty('userId', 1, 'number')  // 设置外键
post.addProperty('title', '新文章', 'string')
post.addProperty('content', '文章内容...', 'string')

await postRepo.save(post)
```

### 查询关联数量

```typescript
// 查询用户的文章数量
const qb = new QueryBuilder('Post')
  .where('userId', ConditionOperator.EQUAL, userId)

const count = await new QueryExecutor(qb).count()
console.log(`用户有 ${count} 篇文章`)
```

### 删除关联

```typescript
// 删除用户的所有文章
const qb = new QueryBuilder('Post')
  .where('userId', ConditionOperator.EQUAL, userId)

const posts = await new QueryExecutor(qb).get()

for (const post of posts) {
  const postId = post.getPropertyValue('id') as number
  await postRepo.removeById(postId)
}
```

### 更新关联

```typescript
// 将文章转移给另一个用户
const post = await postRepo.findById(postId)
if (post !== null) {
  post.setPropertyValue('userId', newUserId)
  await postRepo.save(post)
}
```

---

## 完整示例

### 博客系统 - 用户与文章

```typescript
import {
  defineEntity,
  ColumnType,
  Repository,
  EntityData,
  MetadataStorage,
  RelationMetadata,
  RelationType,
  QueryBuilder,
  QueryExecutor,
  ConditionOperator
} from '@aspect/ocorm'

// 1. 定义实体
defineEntity('User', {
  tableName: 'users',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT },
    { property: 'email', type: ColumnType.TEXT }
  ]
})

defineEntity('Post', {
  tableName: 'posts',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'userId', name: 'user_id', type: ColumnType.INTEGER },
    { property: 'title', type: ColumnType.TEXT },
    { property: 'content', type: ColumnType.TEXT },
    { property: 'status', type: ColumnType.TEXT },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER }
  ]
})

// 2. 注册关系
const storage = MetadataStorage.getInstance()

storage.registerRelation('User', new RelationMetadata(
  RelationType.ONE_TO_MANY,
  'User',
  'Post',
  'posts',
  'userId'
))

storage.registerRelation('Post', new RelationMetadata(
  RelationType.MANY_TO_ONE,
  'Post',
  'User',
  'author',
  'userId'
))

// 3. 服务函数

// 获取用户及其文章
async function getUserWithPosts(userId: number) {
  const qb = new QueryBuilder('User')
    .where('id', ConditionOperator.EQUAL, userId)
    .with('posts')
  
  return await new QueryExecutor(qb).getOne()
}

// 获取用户的已发布文章
async function getPublishedPosts(userId: number, page: number, pageSize: number) {
  const qb = new QueryBuilder('Post')
    .where('userId', ConditionOperator.EQUAL, userId)
    .andWhere('status', ConditionOperator.EQUAL, 'published')
    .orderBy('createdAt', 'DESC')
    .paginate(page, pageSize)
  
  return await new QueryExecutor(qb).getPaginated()
}

// 创建文章
async function createPost(userId: number, title: string, content: string) {
  const postRepo = new Repository('Post')
  
  const post = new EntityData('Post')
  post.addProperty('userId', userId, 'number')
  post.addProperty('title', title, 'string')
  post.addProperty('content', content, 'string')
  post.addProperty('status', 'draft', 'string')
  post.addProperty('createdAt', Date.now(), 'number')
  
  return await postRepo.save(post)
}

// 获取热门文章及作者
async function getPopularPosts(limit: number) {
  const qb = new QueryBuilder('Post')
    .where('status', ConditionOperator.EQUAL, 'published')
    .with('author')
    .orderBy('viewCount', 'DESC')
    .limit(limit)
  
  return await new QueryExecutor(qb).get()
}

// 4. 使用示例
async function example() {
  const userRepo = new Repository('User')
  
  // 创建用户
  const user = new EntityData('User')
  user.addProperty('name', '张三', 'string')
  user.addProperty('email', 'zhangsan@example.com', 'string')
  const userResult = await userRepo.save(user)
  const userId = userResult.insertId
  
  // 创建文章
  await createPost(userId, '第一篇文章', '这是内容...')
  await createPost(userId, '第二篇文章', '更多内容...')
  
  // 查询用户及其文章
  const userWithPosts = await getUserWithPosts(userId)
  if (userWithPosts !== null) {
    const posts = userWithPosts.getRelatedArray('posts')
    console.log(`${userWithPosts.getPropertyValue('name')} 有 ${posts.length} 篇文章`)
  }
  
  // 分页查询
  const pagedPosts = await getPublishedPosts(userId, 1, 10)
  console.log(`已发布文章: ${pagedPosts.total} 篇`)
}
```

### 分类与商品

```typescript
// 分类实体
defineEntity('Category', {
  tableName: 'categories',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT },
    { property: 'description', type: ColumnType.TEXT }
  ]
})

// 商品实体
defineEntity('Product', {
  tableName: 'products',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'categoryId', name: 'category_id', type: ColumnType.INTEGER },
    { property: 'name', type: ColumnType.TEXT },
    { property: 'price', type: ColumnType.REAL },
    { property: 'stock', type: ColumnType.INTEGER }
  ]
})

// 注册关系
storage.registerRelation('Category', new RelationMetadata(
  RelationType.ONE_TO_MANY,
  'Category',
  'Product',
  'products',
  'categoryId'
))

// 查询分类及其商品
async function getCategoryWithProducts(categoryId: number) {
  const qb = new QueryBuilder('Category')
    .where('id', ConditionOperator.EQUAL, categoryId)
    .with('products')
  
  return await new QueryExecutor(qb).getOne()
}

// 查询有库存商品的分类
async function getCategoriesWithStock() {
  const qb = new QueryBuilder('Category')
    .whereExists('products', (sub) => {
      sub.where('stock', ConditionOperator.GREATER, 0)
    })
  
  return await new QueryExecutor(qb).get()
}
```

---

## 注意事项

1. **外键设置**：在"多"方实体中定义外键列，并在保存时正确设置外键值
2. **N+1 问题**：使用 `with` 预加载避免多次查询，提高性能
3. **级联删除**：谨慎使用级联删除，可能导致大量数据被删除
4. **空集合处理**：`getRelatedArray` 返回的可能是空数组，使用前检查
5. **事务一致性**：涉及多表操作时，使用事务确保数据一致性
6. **索引优化**：外键列建议添加索引，提高关联查询性能
