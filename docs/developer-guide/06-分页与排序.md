# 分页与排序

OCORM 提供完善的分页和排序功能，支持通过 `QueryBuilder` 和 `Repository` 进行灵活的数据查询。

---

## 分页查询

### Repository.findPaginated

最简单的分页查询方式，直接通过 Repository 调用：

```typescript
import { Repository } from '@aspect/ocorm'

const userRepo = new Repository('User')

// 查询第 1 页，每页 10 条
const result = await userRepo.findPaginated(1, 10)

console.log(`当前页: ${result.page}`)           // 1
console.log(`每页数量: ${result.pageSize}`)     // 10
console.log(`总记录数: ${result.total}`)        // 100
console.log(`总页数: ${result.totalPages}`)     // 10
console.log(`当前页数据:`, result.data)         // EntityData[]
```

### 包含软删除数据

```typescript
// 默认排除已删除数据
const result = await userRepo.findPaginated(1, 10)

// 包含已删除数据
const allResult = await userRepo.findPaginated(1, 10, true)
```

---

## QueryBuilder 分页

使用 `QueryBuilder` 可以在分页基础上添加更多查询条件。

### paginate 方法

```typescript
import { QueryBuilder, QueryExecutor, ConditionOperator } from '@aspect/ocorm'

const qb = new QueryBuilder('User')
  .where('status', ConditionOperator.EQUAL, 1)
  .paginate(1, 10)  // 第 1 页，每页 10 条

const executor = new QueryExecutor(qb)
const result = await executor.getPaginated()
```

### forPage 方法

`forPage` 是 `paginate` 的别名：

```typescript
const qb = new QueryBuilder('User')
  .forPage(2, 20)  // 第 2 页，每页 20 条
```

### limit / offset 方法

直接设置 LIMIT 和 OFFSET：

```typescript
const qb = new QueryBuilder('User')
  .limit(10)   // 限制返回 10 条
  .offset(20)  // 跳过前 20 条

// 等价于: SELECT * FROM users LIMIT 10 OFFSET 20
```

### 组合使用

```typescript
const qb = new QueryBuilder('User')
  .where('age', ConditionOperator.GREATER, 18)
  .andWhere('status', ConditionOperator.EQUAL, 1)
  .orderBy('createdAt', 'DESC')
  .paginate(1, 10)

const result = await new QueryExecutor(qb).getPaginated()
```

---

## PaginatedResult 结构

分页查询返回 `PaginatedResult` 对象：

```typescript
class PaginatedResult {
  data: Array<EntityData>  // 当前页数据
  total: number            // 总记录数
  page: number             // 当前页码（从 1 开始）
  pageSize: number         // 每页数量
  totalPages: number       // 总页数
}
```

### 辅助方法

```typescript
const result = await userRepo.findPaginated(1, 10)

// 检查是否有下一页
result.hasNextPage()      // true/false

// 检查是否有上一页
result.hasPreviousPage()  // true/false

// 检查是否为第一页
result.isFirstPage()      // true/false

// 检查是否为最后一页
result.isLastPage()       // true/false

// 获取当前页实际数据量
result.getCurrentPageSize()  // number

// 检查结果是否为空
result.isEmpty()          // true/false
```

---

## 排序

### orderBy 方法

```typescript
const qb = new QueryBuilder('User')

// 单字段排序 - 升序
qb.orderBy('name', 'ASC')

// 单字段排序 - 降序
qb.orderBy('createdAt', 'DESC')
```

### 多字段排序

支持链式调用设置多个排序字段：

```typescript
const qb = new QueryBuilder('User')
  .orderBy('status', 'DESC')    // 优先按状态降序
  .orderBy('createdAt', 'DESC') // 再按创建时间降序
  .orderBy('name', 'ASC')       // 最后按名称升序

// 等价于: ORDER BY status DESC, created_at DESC, name ASC
```

### 排序 + 分页组合

```typescript
const qb = new QueryBuilder('Article')
  .where('status', ConditionOperator.EQUAL, 'published')
  .orderBy('viewCount', 'DESC')   // 按浏览量降序
  .orderBy('createdAt', 'DESC')   // 相同浏览量按时间降序
  .paginate(1, 20)

const result = await new QueryExecutor(qb).getPaginated()
```

---

## 获取查询信息

```typescript
const qb = new QueryBuilder('User')
  .orderBy('name', 'ASC')
  .paginate(2, 10)

// 获取排序信息
const orderByClauses = qb.getOrderByColumns()
// [{ column: 'name', direction: 'ASC' }]

// 获取分页信息
qb.hasPagination()      // true
qb.getPageNumber()      // 2
qb.getPageSizeValue()   // 10
qb.getLimitValue()      // 10
qb.getOffsetValue()     // 10 (page-1)*pageSize

// 获取分页参数对象
const params = qb.getPaginationParams()
// { page: 2, pageSize: 10 }
```

---

## 完整示例

### 用户列表分页

```typescript
import { Repository, QueryBuilder, QueryExecutor, ConditionOperator } from '@aspect/ocorm'

async function getUserList(page: number, pageSize: number, status?: number) {
  const qb = new QueryBuilder('User')
  
  // 添加条件
  if (status !== undefined) {
    qb.where('status', ConditionOperator.EQUAL, status)
  }
  
  // 设置排序和分页
  qb.orderBy('createdAt', 'DESC')
    .paginate(page, pageSize)
  
  return await new QueryExecutor(qb).getPaginated()
}

// 使用
const result = await getUserList(1, 20, 1)
console.log(`共 ${result.total} 条记录，当前显示第 ${result.page}/${result.totalPages} 页`)
```

### 文章搜索分页

```typescript
async function searchArticles(
  keyword: string,
  page: number,
  pageSize: number
) {
  const qb = new QueryBuilder('Article')
    .where('status', ConditionOperator.EQUAL, 'published')
    .andWhere('title', ConditionOperator.LIKE, `%${keyword}%`)
    .orderBy('viewCount', 'DESC')
    .paginate(page, pageSize)
  
  const result = await new QueryExecutor(qb).getPaginated()
  
  return {
    articles: result.data,
    pagination: {
      current: result.page,
      pageSize: result.pageSize,
      total: result.total,
      pages: result.totalPages,
      hasNext: result.hasNextPage(),
      hasPrev: result.hasPreviousPage()
    }
  }
}
```

---

## 注意事项

1. **页码从 1 开始**：`paginate(1, 10)` 表示第 1 页，不是第 0 页
2. **OFFSET 自动计算**：使用 `paginate` 时，OFFSET = (page - 1) × pageSize
3. **排序顺序**：多次调用 `orderBy` 按调用顺序依次排序
4. **性能考虑**：大数据量分页建议配合索引使用，避免深分页（页码过大）
