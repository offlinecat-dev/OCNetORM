# 关联加载策略

关联加载策略决定了如何以及何时加载实体的关联数据。OCORM 提供了预加载（Eager Loading）和延迟加载（Lazy Loading）两种策略。

---

## 预加载（Eager Loading）

### with 方法

使用 `with` 方法在查询时立即加载关联数据，避免 N+1 查询问题：

```typescript
import { QueryBuilder, QueryExecutor, ConditionOperator } from '@offlinecat/ocorm'

// 查询用户并预加载文章
const qb = new QueryBuilder('User')
  .where('id', ConditionOperator.EQUAL, 1)
  .with('posts')  // 预加载 posts 关联

const user = await new QueryExecutor(qb).getOne()

if (user !== null) {
  // 关联数据已加载，直接访问
  const posts = user.getRelatedArray('posts')
  console.log(`用户有 ${posts.length} 篇文章`)
}
```

### 多关联预加载

可以同时预加载多个关联：

```typescript
const qb = new QueryBuilder('User')
  .with('posts')    // 用户的文章
  .with('profile')  // 用户的资料

const users = await new QueryExecutor(qb).get()

for (const user of users) {
  const posts = user.getRelatedArray('posts')
  const profile = user.getRelatedSingle('profile')
  
  console.log(`${user.getPropertyValue('name')}:`)
  console.log(`  文章数: ${posts.length}`)
  console.log(`  简介: ${profile?.getPropertyValue('bio')}`)
}
```

### 检查预加载配置

```typescript
const qb = new QueryBuilder('User')
  .with('posts')
  .with('profile')

// 检查是否有关联需要加载
if (qb.hasRelations()) {
  const relationNames = qb.getRelationNames()
  console.log('需要加载的关联:', relationNames)  // ['posts', 'profile']
}
```

### 关联增强用法（嵌套加载 + 条件过滤 + 计数）

```typescript
import { QueryBuilder, QueryExecutor, ConditionOperator } from '@offlinecat/ocorm'

const qb = new QueryBuilder('User')
  .with('posts.tags')  // 嵌套预加载
  .withWhere('posts', (postQb) => {
    postQb.where('viewCount', ConditionOperator.GREATER_EQUAL, 100)
      .orderBy('createdAt', 'DESC')
      .limit(5)
  })
  .withCount('posts')  // 默认别名 posts_count

const users = await new QueryExecutor(qb).get()

for (const user of users) {
  const posts = user.getRelatedArray('posts')
  const postsCount = Number(user.getPropertyValue('posts_count'))
  console.log(`用户 ${user.getPropertyValue('name')}：过滤后文章 ${posts.length}，总文章数 ${postsCount}`)
}
```

---

## 延迟加载（Lazy Loading）

### withLazy 方法

使用 `withLazy` 方法标记关联为延迟加载，关联数据可在需要时通过 `loadRelatedArray` / `loadRelatedSingle` 显式触发加载：

```typescript
const qb = new QueryBuilder('User')
  .where('id', ConditionOperator.EQUAL, 1)
  .withLazy('posts')  // 延迟加载 posts

const user = await new QueryExecutor(qb).getOne()

// 此时 posts 尚未加载
// 需要显式触发加载：await user.loadRelatedArray('posts')
```

### 检查延迟加载配置

```typescript
const qb = new QueryBuilder('User')
  .withLazy('posts')
  .withLazy('profile')

// 检查是否有延迟加载关联
if (qb.hasLazyRelations()) {
  const lazyNames = qb.getLazyRelationNames()
  console.log('延迟加载的关联:', lazyNames)  // ['posts', 'profile']
}
```

---

## RelationLoader

`RelationLoader` 是 OCORM 的关联数据加载器，负责执行关联数据的二次查询。

### 基本用法

```typescript
import { RelationLoader, EntityData } from '@offlinecat/ocorm'

// 创建加载器
const loader = new RelationLoader('User')

// 加载单个关联
const usersWithPosts = await loader.loadRelation(users, 'posts')
```

### 并行加载多个关联

`RelationLoader` 支持并行加载多个关联，提高查询效率：

```typescript
const loader = new RelationLoader('User')

// 并行加载多个关联
const users = await loader.loadRelationsParallel(
  userEntities,
  ['posts', 'profile', 'comments']
)

// 所有关联数据已加载到各实体中
```

### 加载策略

RelationLoader 根据关系类型采用不同的加载策略：

| 关系类型 | 加载策略 |
|----------|----------|
| ONE_TO_ONE | 根据 `foreignKeySide` 配置，通过外键或主键批量查询 |
| ONE_TO_MANY | 收集主实体主键，使用 IN 条件批量查询关联实体 |
| MANY_TO_ONE | 收集主实体外键，使用 IN 条件批量查询目标实体 |
| MANY_TO_MANY | 两次查询：先查中间表获取目标ID，再查询目标实体 |

### IN 条件分批处理

为避免 SQLite 参数数量限制（默认 999），RelationLoader 会自动将大量 IN 条件分批处理：

```typescript
// 内部实现：每批最多 500 个参数
private static readonly IN_CLAUSE_LIMIT: number = 500

// 自动分批处理
const batches = this.splitIntoBatches(pkValues, RelationLoader.IN_CLAUSE_LIMIT)
for (const batch of batches) {
  // 执行批量查询
}
```

---

## 访问关联数据

### getRelatedSingle - 获取单个关联

用于 ONE_TO_ONE 和 MANY_TO_ONE 关系：

```typescript
// 获取用户的资料（一对一）
const profile = user.getRelatedSingle('profile')

if (profile !== null) {
  console.log(`头像: ${profile.getPropertyValue('avatar')}`)
  console.log(`简介: ${profile.getPropertyValue('bio')}`)
}

// 获取文章的作者（多对一）
const author = post.getRelatedSingle('author')
console.log(`作者: ${author?.getPropertyValue('name')}`)
```

### getRelatedArray - 获取关联集合

用于 ONE_TO_MANY 和 MANY_TO_MANY 关系：

```typescript
// 获取用户的文章列表（一对多）
const posts = user.getRelatedArray('posts')

for (const post of posts) {
  console.log(`- ${post.getPropertyValue('title')}`)
}

// 获取文章的标签列表（多对多）
const tags = post.getRelatedArray('tags')
const tagNames = tags.map(t => t.getPropertyValue('name')).join(', ')
console.log(`标签: ${tagNames}`)
```

### 内部方法

EntityData 还提供了内部使用的设置方法：

```typescript
// 设置单个关联（ONE_TO_ONE, MANY_TO_ONE）
entity.setRelatedSingle('profile', profileEntity)
entity.setRelatedSingle('author', authorEntity)

// 设置关联集合（ONE_TO_MANY, MANY_TO_MANY）
entity.setRelatedArray('posts', postEntities)
entity.setRelatedArray('tags', tagEntities)

// 获取原始关联数据
const singleRelated = entity.getRelatedSingle('profile')
const arrayRelated = entity.getRelatedArray('posts')
```

---

## 加载结果追踪

### RelationLoadResult

每次关联加载都会生成加载结果对象：

```typescript
import { RelationLoadResult } from '@offlinecat/ocorm'

// 成功结果
const successResult = RelationLoadResult.createSuccess(
  'posts',      // 关联名称
  10,           // 加载的数据数量
  25            // 耗时（毫秒）
)

// 失败结果
const failureResult = RelationLoadResult.createFailure(
  'posts',
  '关联未注册',
  5
)

// 检查结果
if (successResult.success) {
  console.log(`加载了 ${successResult.loadedCount} 条关联数据`)
  console.log(`耗时: ${successResult.duration}ms`)
}
```

### ParallelRelationLoadResult

并行加载时会生成聚合结果：

```typescript
import { ParallelRelationLoadResult } from '@offlinecat/ocorm'

const parallelResult = new ParallelRelationLoadResult()
parallelResult.addResult(result1)
parallelResult.addResult(result2)
parallelResult.totalDuration = 100

// 获取统计信息
console.log(`总耗时: ${parallelResult.totalDuration}ms`)
console.log(`成功: ${parallelResult.getSuccessCount()}`)
console.log(`失败: ${parallelResult.getFailureCount()}`)
```

---

## 最佳实践

### 避免 N+1 查询

**错误做法**（N+1 问题）：

```typescript
// ❌ 每个用户都会触发一次额外查询
const users = await userRepo.findAll()

for (const user of users) {
  // 这里会为每个用户单独查询文章
  const posts = await postRepo.findByUserId(user.id)
}
```

**正确做法**（预加载）：

```typescript
// ✓ 只执行 2 次查询：查用户 + 查所有相关文章
const qb = new QueryBuilder('User')
  .with('posts')

const users = await new QueryExecutor(qb).get()

for (const user of users) {
  const posts = user.getRelatedArray('posts')  // 已加载，无额外查询
}
```

### 按需加载

只加载需要的关联，避免过度加载：

```typescript
// ✓ 只加载需要展示的关联
const qb = new QueryBuilder('User')
  .with('profile')  // 列表页只需要头像

// ❌ 不要加载不需要的关联
const qb = new QueryBuilder('User')
  .with('posts')
  .with('profile')
  .with('comments')
  .with('followers')  // 列表页不需要这些
```

### 分页时的关联加载

```typescript
// 分页查询并加载关联
const qb = new QueryBuilder('Post')
  .with('author')
  .with('tags')
  .orderBy('createdAt', 'DESC')
  .paginate(page, pageSize)

const result = await new QueryExecutor(qb).getPaginated()

// 分页数据中的每条记录都已加载关联
for (const post of result.data) {
  const author = post.getRelatedSingle('author')
  const tags = post.getRelatedArray('tags')
}
```

---

## 完整示例

```typescript
import {
  Repository,
  EntityData,
  QueryBuilder,
  QueryExecutor,
  RelationLoader,
  ConditionOperator
} from '@offlinecat/ocorm'

// 1. 使用 QueryBuilder 预加载
async function getUsersWithRelations() {
  const qb = new QueryBuilder('User')
    .with('posts')
    .with('profile')
    .orderBy('createdAt', 'DESC')
    .limit(10)
  
  return await new QueryExecutor(qb).get()
}

// 2. 使用 RelationLoader 手动加载
async function loadRelationsManually(users: EntityData[]) {
  const loader = new RelationLoader('User')
  
  // 并行加载多个关联
  await loader.loadRelationsParallel(users, ['posts', 'profile'])
  
  return users
}

// 3. 条件查询并加载关联
async function getActiveUsersWithPosts() {
  const qb = new QueryBuilder('User')
    .where('status', ConditionOperator.EQUAL, 1)
    .whereExists('posts', (subQuery) => {
      subQuery.where('status', ConditionOperator.EQUAL, 'published')
    })
    .with('posts')
  
  return await new QueryExecutor(qb).get()
}

// 4. 使用示例
async function example() {
  // 获取用户列表（带关联）
  const users = await getUsersWithRelations()
  
  for (const user of users) {
    console.log(`\n用户: ${user.getPropertyValue('name')}`)
    
    // 访问一对一关联
    const profile = user.getRelatedSingle('profile')
    if (profile !== null) {
      console.log(`  简介: ${profile.getPropertyValue('bio')}`)
    }
    
    // 访问一对多关联
    const posts = user.getRelatedArray('posts')
    console.log(`  文章数: ${posts.length}`)
    for (const post of posts.slice(0, 3)) {
      console.log(`    - ${post.getPropertyValue('title')}`)
    }
  }
}
```

---

## 注意事项

1. **预加载 vs 延迟加载**：列表页推荐预加载，详情页可考虑按需延迟加载
2. **关联数量**：避免一次预加载过多关联，会增加内存消耗
3. **数据量控制**：大数据量场景下，关联数据也应考虑分页或限制数量
4. **空值处理**：访问关联数据前检查是否为 null 或空数组
5. **循环引用**：避免定义会导致无限递归的关联加载
6. **性能监控**：使用 RelationLoadResult 监控关联加载性能

