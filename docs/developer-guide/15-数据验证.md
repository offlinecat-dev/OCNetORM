# 数据验证

数据验证用于确保实体数据在保存到数据库之前符合业务规则。OCORM 提供了内置的验证规则和验证器。

---

## 验证规则类型

OCORM 内置以下验证规则：

| 规则类型 | 说明 | 参数 |
|----------|------|------|
| `required` | 必填验证 | 无 |
| `length` | 长度验证 | `min`, `max` |
| `email` | 邮箱格式验证 | 无 |

---

## 验证规则注册

### ValidationMetadataStorage

使用 `ValidationMetadataStorage` 注册验证规则：

```typescript
import { ValidationMetadataStorage, MetadataStorage } from '@offlinecat/ocorm'

// 先注册实体
MetadataStorage.getInstance().registerEntity('User', 'users')

// 获取验证元数据存储实例
const validationStorage = ValidationMetadataStorage.getInstance()

// 注册验证规则
validationStorage.registerRule('User', 'name', { type: 'required' })
validationStorage.registerRule('User', 'name', { type: 'length', min: 2, max: 50 })
validationStorage.registerRule('User', 'email', { type: 'required' })
validationStorage.registerRule('User', 'email', { type: 'email' })
```

### ValidationRule 接口

```typescript
type ValidationRuleType = 'required' | 'length' | 'email'

interface ValidationRule {
  type: ValidationRuleType
  min?: number   // 最小长度（仅 length 规则）
  max?: number   // 最大长度（仅 length 规则）
}
```

---

## Required - 必填验证

### 基本用法

验证字段不能为空：

```typescript
const validationStorage = ValidationMetadataStorage.getInstance()

// 注册必填规则
validationStorage.registerRule('User', 'name', { type: 'required' })
validationStorage.registerRule('User', 'email', { type: 'required' })
```

### 验证逻辑

以下情况会触发必填验证失败：

- 值为 `null`
- 值为 `undefined`（属性不存在）
- 字符串为空 `""`
- 字符串仅包含空格 `"   "`

```typescript
// 验证失败的示例
const data = new EntityData('User')
data.setPropertyValue('name', null)      // ❌ 失败
data.setPropertyValue('name', '')        // ❌ 失败
data.setPropertyValue('name', '   ')     // ❌ 失败

// 验证通过的示例
data.setPropertyValue('name', 'John')    // ✓ 通过
data.setPropertyValue('name', '张三')    // ✓ 通过
```

### RequiredValidationError

验证失败时抛出：

```typescript
import { RequiredValidationError } from '@offlinecat/ocorm'

// 错误信息格式
// 字段 name 为必填项
```

---

## Length - 长度验证

### 基本用法

验证字符串长度在指定范围内：

```typescript
const validationStorage = ValidationMetadataStorage.getInstance()

// 长度范围验证（2-50 个字符）
validationStorage.registerRule('User', 'name', {
  type: 'length',
  min: 2,
  max: 50
})

// 仅最小长度
validationStorage.registerRule('Article', 'content', {
  type: 'length',
  min: 10
})

// 仅最大长度
validationStorage.registerRule('User', 'bio', {
  type: 'length',
  max: 200
})
```

### 验证逻辑

```typescript
// 假设规则：min: 2, max: 10

// 验证失败
data.setPropertyValue('name', 'a')           // ❌ 太短（1 < 2）
data.setPropertyValue('name', 'abcdefghijk') // ❌ 太长（11 > 10）

// 验证通过
data.setPropertyValue('name', 'ab')          // ✓ 通过（边界值）
data.setPropertyValue('name', 'abcdefghij')  // ✓ 通过（边界值）
data.setPropertyValue('name', 'John')        // ✓ 通过

// 空值处理：不存在的属性或值为 null 不触发长度验证
// 空字符串会参与长度验证（长度为 0），需根据 min/max 配置决定是否通过
data.setPropertyValue('name', null)          // ✓ 跳过验证（需配合 required 使用）
data.setPropertyValue('name', '')            // 参与长度验证（长度为 0）
```

### LengthValidationError

验证失败时抛出：

```typescript
import { LengthValidationError } from '@offlinecat/ocorm'

// 错误信息格式
// 字段 name 长度需在 2 到 50 之间
```

---

## Email - 邮箱验证

### 基本用法

验证字段是有效的邮箱格式：

```typescript
const validationStorage = ValidationMetadataStorage.getInstance()

validationStorage.registerRule('User', 'email', { type: 'email' })
```

### 验证逻辑

使用正则表达式验证邮箱格式：`/^[^\s@]+@[^\s@]+\.[^\s@]+$/`

```typescript
// 验证通过的邮箱
data.setPropertyValue('email', 'user@example.com')      // ✓
data.setPropertyValue('email', 'user.name@domain.org')  // ✓
data.setPropertyValue('email', 'user+tag@example.co.uk') // ✓

// 验证失败的邮箱
data.setPropertyValue('email', 'invalid-email')         // ❌
data.setPropertyValue('email', '@nodomain.com')         // ❌
data.setPropertyValue('email', 'no@domain')             // ❌
data.setPropertyValue('email', 'missing@.com')          // ❌

// 空值处理：空字符串跳过验证（需配合 required 使用）
data.setPropertyValue('email', '')                      // ✓ 跳过验证
data.setPropertyValue('email', null)                    // ✓ 跳过验证
```

### EmailValidationError

验证失败时抛出：

```typescript
import { EmailValidationError } from '@offlinecat/ocorm'

// 错误信息格式
// 字段 email 不是有效的邮箱地址
```

---

## EntityValidator

### validate 方法

执行验证并返回 `ValidationResult`：

```typescript
import { EntityValidator, ValidationResult, EntityData } from '@offlinecat/ocorm'

const data = new EntityData('User')
data.setPropertyValue('name', '')
data.setPropertyValue('email', 'invalid')

// 执行验证
const result: ValidationResult = EntityValidator.validate('User', data)

// 检查验证结果
if (result.isValid()) {
  console.log('验证通过')
} else {
  console.log('验证失败')
  console.log('错误数量:', result.errors.length)
  console.log('错误摘要:', result.getSummary())
}
```

### validateOrThrow 方法

验证失败时抛出异常：

```typescript
import { EntityValidator, EntityValidationError } from '@offlinecat/ocorm'

try {
  EntityValidator.validateOrThrow('User', data)
  console.log('验证通过，可以保存')
} catch (error) {
  if (error instanceof EntityValidationError) {
    console.log('验证失败:', error.message)
  }
}
```

---

## ValidationResult

### 属性和方法

```typescript
class ValidationResult {
  errors: Array<ValidationError> = []
  
  // 添加错误
  addError(error: ValidationError): void
  
  // 检查是否有效
  isValid(): boolean
  
  // 获取第一个错误
  getFirstError(): ValidationError | null
  
  // 获取错误摘要（用分号分隔）
  getSummary(): string
}
```

### 使用示例

```typescript
const result = EntityValidator.validate('User', data)

// 检查是否有效
if (!result.isValid()) {
  // 获取第一个错误
  const firstError = result.getFirstError()
  if (firstError !== null) {
    console.log('第一个错误:', firstError.message)
    console.log('错误类型:', firstError.name)
  }
  
  // 获取所有错误
  for (const error of result.errors) {
    console.log(`- ${error.message}`)
  }
  
  // 获取错误摘要
  const summary = result.getSummary()
  // 输出：字段 name 为必填项; 字段 email 不是有效的邮箱地址
}
```

---

## 查询验证规则

### hasRules - 检查是否有规则

```typescript
const validationStorage = ValidationMetadataStorage.getInstance()

// 检查实体是否有验证规则
const hasRules = validationStorage.hasRules('User')
console.log(`User 有验证规则: ${hasRules}`)
```

### getRules - 获取所有规则

```typescript
// 获取实体的所有验证规则
const rules: Map<string, Array<ValidationRule>> = validationStorage.getRules('User')

// 遍历规则
rules.forEach((propertyRules, propertyName) => {
  console.log(`${propertyName}:`)
  for (const rule of propertyRules) {
    console.log(`  - ${rule.type}`)
  }
})
```

### getRulesForProperty - 获取属性规则

```typescript
// 获取特定属性的验证规则
const nameRules = validationStorage.getRulesForProperty('User', 'name')

for (const rule of nameRules) {
  console.log(`规则类型: ${rule.type}`)
  if (rule.type === 'length') {
    console.log(`  最小长度: ${rule.min}`)
    console.log(`  最大长度: ${rule.max}`)
  }
}
```

---

## 完整示例

### 用户注册验证

```typescript
import {
  defineEntity,
  ColumnType,
  MetadataStorage,
  ValidationMetadataStorage,
  EntityValidator,
  ValidationResult,
  Repository,
  EntityData
} from '@offlinecat/ocorm'

// 1. 定义实体
defineEntity('User', {
  tableName: 'users',
  columns: [
    { property: 'id', primaryKey: true, autoIncrement: true },
    { property: 'name', type: ColumnType.TEXT, nullable: false },
    { property: 'email', type: ColumnType.TEXT, nullable: false },
    { property: 'password', type: ColumnType.TEXT, nullable: false },
    { property: 'bio', type: ColumnType.TEXT },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER }
  ]
})

// 2. 注册验证规则
function registerUserValidation() {
  const storage = ValidationMetadataStorage.getInstance()
  
  // 用户名：必填，2-50 个字符
  storage.registerRule('User', 'name', { type: 'required' })
  storage.registerRule('User', 'name', { type: 'length', min: 2, max: 50 })
  
  // 邮箱：必填，有效格式
  storage.registerRule('User', 'email', { type: 'required' })
  storage.registerRule('User', 'email', { type: 'email' })
  
  // 密码：必填，最少 6 个字符
  storage.registerRule('User', 'password', { type: 'required' })
  storage.registerRule('User', 'password', { type: 'length', min: 6 })
  
  // 简介：可选，最多 200 个字符
  storage.registerRule('User', 'bio', { type: 'length', max: 200 })
}

// 3. 用户服务
class UserService {
  private repo = new Repository('User')
  
  async register(
    name: string,
    email: string,
    password: string,
    bio?: string
  ): Promise<{ success: boolean; userId?: number; errors?: string }> {
    // 构建实体数据
    const userData = new EntityData('User')
    userData.setPropertyValue('name', name)
    userData.setPropertyValue('email', email)
    userData.setPropertyValue('password', password)
    if (bio) {
      userData.setPropertyValue('bio', bio)
    }
    userData.setPropertyValue('createdAt', Date.now())
    
    // 执行验证
    const result = EntityValidator.validate('User', userData)
    
    if (!result.isValid()) {
      return {
        success: false,
        errors: result.getSummary()
      }
    }
    
    // 验证通过，保存数据
    try {
      const saveResult = await this.repo.save(userData)
      return {
        success: true,
        userId: saveResult.insertId
      }
    } catch (error) {
      return {
        success: false,
        errors: error.message
      }
    }
  }
}

// 4. 使用示例
async function example() {
  // 注册验证规则
  registerUserValidation()
  
  const userService = new UserService()
  
  // 测试1：验证失败
  const result1 = await userService.register('', 'invalid-email', '123')
  console.log('测试1:', result1)
  // { success: false, errors: '字段 name 为必填项; 字段 email 不是有效的邮箱地址; 字段 password 长度需在 6 到 ...' }
  
  // 测试2：验证通过
  const result2 = await userService.register(
    '张三',
    'zhangsan@example.com',
    'password123',
    '全栈开发工程师'
  )
  console.log('测试2:', result2)
  // { success: true, userId: 1 }
}
```

### 文章发布验证

```typescript
// 定义文章实体
defineEntity('Article', {
  tableName: 'articles',
  columns: [
    { property: 'id', primaryKey: true, autoIncrement: true },
    { property: 'title', type: ColumnType.TEXT },
    { property: 'content', type: ColumnType.TEXT },
    { property: 'summary', type: ColumnType.TEXT },
    { property: 'authorId', name: 'author_id', type: ColumnType.INTEGER }
  ]
})

// 注册文章验证规则
function registerArticleValidation() {
  const storage = ValidationMetadataStorage.getInstance()
  
  // 标题：必填，5-100 个字符
  storage.registerRule('Article', 'title', { type: 'required' })
  storage.registerRule('Article', 'title', { type: 'length', min: 5, max: 100 })
  
  // 内容：必填，最少 100 个字符
  storage.registerRule('Article', 'content', { type: 'required' })
  storage.registerRule('Article', 'content', { type: 'length', min: 100 })
  
  // 摘要：可选，最多 300 个字符
  storage.registerRule('Article', 'summary', { type: 'length', max: 300 })
}

// 文章服务
class ArticleService {
  private repo = new Repository('Article')
  
  async publish(title: string, content: string, authorId: number, summary?: string) {
    const article = new EntityData('Article')
    article.setPropertyValue('title', title)
    article.setPropertyValue('content', content)
    article.setPropertyValue('authorId', authorId)
    if (summary) {
      article.setPropertyValue('summary', summary)
    }
    
    // 使用 validateOrThrow 直接抛出异常
    try {
      EntityValidator.validateOrThrow('Article', article)
      return await this.repo.save(article)
    } catch (error) {
      console.error('发布失败:', error.message)
      throw error
    }
  }
}
```

---

## 验证错误类型

### 错误类继承关系

```
OrmError
  └── ValidationError
        ├── RequiredValidationError
        ├── LengthValidationError
        ├── EmailValidationError
        └── EntityValidationError
```

### 错误处理示例

```typescript
import {
  ValidationError,
  RequiredValidationError,
  LengthValidationError,
  EmailValidationError,
  EntityValidationError
} from '@offlinecat/ocorm'

const result = EntityValidator.validate('User', data)

for (const error of result.errors) {
  if (error instanceof RequiredValidationError) {
    console.log(`必填字段缺失: ${error.message}`)
  } else if (error instanceof LengthValidationError) {
    console.log(`长度不符合: ${error.message}`)
  } else if (error instanceof EmailValidationError) {
    console.log(`邮箱格式错误: ${error.message}`)
  } else if (error instanceof EntityValidationError) {
    console.log(`实体验证错误: ${error.message}`)
  }
}
```

---

## 与 Repository 集成

### Repository.save 内置验证

`Repository.save()` 会在保存前自动执行数据验证（内部调用 `EntityValidator.validateOrThrow(entityName, entityData)`）。

```typescript
import { Repository, EntityData, ValidationError } from '@offlinecat/ocorm'

const repo = new Repository('User')

try {
  const userData = new EntityData('User')
  userData.setPropertyValue('name', '')
  userData.setPropertyValue('email', 'invalid')

  await repo.save(userData)  // 验证失败会抛出 ValidationError / EntityValidationError
} catch (error) {
  if (error instanceof ValidationError) {
    console.log('验证失败:', error.message)
  } else {
    console.log('保存失败:', error.message)
  }
}
```

---

## 注意事项

1. **规则顺序**：同一属性的多个规则按注册顺序执行
2. **空值处理**：`required` 会对 null/undefined/空字符串/纯空格判失败；`length` 仅在属性存在且值非 null 时执行（空字符串会参与长度校验）；`email` 对 null/空字符串跳过验证，需配合 `required` 使用
3. **实体注册**：注册验证规则前必须先注册实体，否则会抛出 `EntityNotRegisteredError`
4. **错误聚合**：`validate` 方法会收集所有错误，不会在第一个错误时停止
5. **性能考虑**：验证逻辑在内存中执行，不涉及数据库操作
6. **自定义验证**：复杂业务验证可在生命周期钩子中实现

