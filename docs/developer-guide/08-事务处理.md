# 事务处理

OCORM 提供完善的事务管理功能，确保数据操作的原子性、一致性、隔离性和持久性（ACID）。

---

## 基础事务

### transaction 方法

通过 `Repository.transaction()` 在事务中执行操作：

```typescript
import { Repository, EntityData } from '@aspect/ocorm'

const userRepo = new Repository('User')

const result = await userRepo.transaction(async (txRepo) => {
  // 在事务中执行操作
  const user = new EntityData('User')
  user.addProperty('name', '张三', 'string')
  user.addProperty('email', 'zhangsan@example.com', 'string')
  
  await txRepo.save(user)
  
  // 如果这里抛出异常，事务将自动回滚
})

if (result.success) {
  console.log('事务提交成功')
}
```

### 事务回调

回调函数接收一个 `Repository` 实例作为参数，所有数据库操作都应通过这个实例执行：

```typescript
await userRepo.transaction(async (txRepo) => {
  // ✓ 正确：使用 txRepo 执行操作
  await txRepo.save(userData)
  await txRepo.removeById(1)
  
  // ✗ 错误：不要使用外部的 repo
  // await userRepo.save(userData)  // 这不会在事务中
})
```

---

## 事务提交与回滚

### 自动提交

回调函数正常执行完毕后，事务自动提交：

```typescript
await userRepo.transaction(async (txRepo) => {
  await txRepo.save(user1)
  await txRepo.save(user2)
  // 执行完毕，事务自动提交
})
```

### 自动回滚

回调函数抛出异常时，事务自动回滚：

```typescript
const countBefore = await userRepo.count()

try {
  await userRepo.transaction(async (txRepo) => {
    await txRepo.save(user1)  // 先插入一条
    
    throw new Error('业务逻辑错误')  // 抛出异常
  })
} catch (e) {
  // 事务已回滚
}

const countAfter = await userRepo.count()
// countAfter === countBefore，数据未改变
```

### 手动触发回滚

通过抛出异常来触发回滚：

```typescript
await userRepo.transaction(async (txRepo) => {
  const user = await txRepo.findById(1)
  
  if (user === null) {
    throw new Error('用户不存在，取消操作')
  }
  
  // 继续执行...
})
```

---

## TransactionResult

事务执行返回 `TransactionResult` 对象：

```typescript
class TransactionResult {
  success: boolean      // 是否成功
  errorMessage: string  // 错误信息
}
```

### 使用示例

```typescript
const result = await userRepo.transaction(async (txRepo) => {
  await txRepo.save(userData)
})

if (result.success) {
  console.log('事务执行成功')
} else {
  console.log(`事务执行失败: ${result.errorMessage}`)
}
```

---

## TransactionOptions - 事务选项

通过 `TransactionOptions` 配置事务行为。

### 选项属性

```typescript
class TransactionOptions {
  isolation: IsolationLevel  // 隔离级别，默认 READ_COMMITTED
  timeout: number            // 超时时间（毫秒），默认 30000
  retries: number            // 失败重试次数，默认 0
  retryDelay: number         // 重试延迟（毫秒），默认 100
  readOnly: boolean          // 是否只读事务，默认 false
}
```

### 使用自定义选项

```typescript
import { Repository, TransactionOptions, IsolationLevel } from '@aspect/ocorm'

const userRepo = new Repository('User')

// 创建自定义选项
const options = new TransactionOptions()
options.timeout = 60000        // 60 秒超时
options.retries = 3            // 失败重试 3 次
options.retryDelay = 500       // 重试间隔 500ms

await userRepo.transactionWithOptions(async (txRepo) => {
  await txRepo.save(userData)
}, options)
```

### 预设选项

```typescript
// 默认选项
const defaultOptions = TransactionOptions.createDefault()

// 只读事务
const readOnlyOptions = TransactionOptions.readOnly()

// 带重试的事务
const retryOptions = TransactionOptions.withRetry(3, 100)

// 带超时的事务
const timeoutOptions = TransactionOptions.withTimeout(60000)

// 串行化隔离级别
const serializableOptions = TransactionOptions.serializable()
```

### 从配置对象创建

```typescript
const options = TransactionOptions.fromConfig({
  isolation: IsolationLevel.SERIALIZABLE,
  timeout: 30000,
  retries: 2,
  retryDelay: 200,
  readOnly: false
})
```

---

## IsolationLevel - 隔离级别

OCORM 支持 SQLite 的事务隔离级别：

```typescript
enum IsolationLevel {
  READ_UNCOMMITTED = 'READ_UNCOMMITTED',  // 读未提交
  READ_COMMITTED = 'READ_COMMITTED',      // 读已提交（默认）
  REPEATABLE_READ = 'REPEATABLE_READ',    // 可重复读
  SERIALIZABLE = 'SERIALIZABLE'           // 串行化
}
```

### 隔离级别说明

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 说明 |
|----------|------|------------|------|------|
| READ_UNCOMMITTED | 可能 | 可能 | 可能 | 最低隔离，性能最好 |
| READ_COMMITTED | 不可能 | 可能 | 可能 | SQLite 默认级别 |
| REPEATABLE_READ | 不可能 | 不可能 | 可能 | 保证重复读一致 |
| SERIALIZABLE | 不可能 | 不可能 | 不可能 | 最高隔离，性能最低 |

### 设置隔离级别

```typescript
const options = new TransactionOptions()
options.isolation = IsolationLevel.SERIALIZABLE

await userRepo.transactionWithOptions(async (txRepo) => {
  // 串行化隔离级别下执行
  await txRepo.save(userData)
}, options)
```

---

## 事务中的 CRUD 操作

### 插入操作

```typescript
await userRepo.transaction(async (txRepo) => {
  const user = new EntityData('User')
  user.addProperty('name', '张三', 'string')
  
  const result = await txRepo.save(user)
  console.log(`插入成功，ID: ${result.insertId}`)
})
```

### 更新操作

```typescript
await userRepo.transaction(async (txRepo) => {
  // 查询并更新
  const user = await txRepo.findById(1)
  if (user !== null) {
    user.setPropertyValue('name', '李四')
    await txRepo.save(user)
  }
})
```

### 删除操作

```typescript
await userRepo.transaction(async (txRepo) => {
  const result = await txRepo.removeById(1)
  if (result.success) {
    console.log('删除成功')
  }
})
```

### 多表操作

```typescript
const userRepo = new Repository('User')
const postRepo = new Repository('Post')

await userRepo.transaction(async (txRepo) => {
  // 在同一事务中操作多个表
  const user = new EntityData('User')
  user.addProperty('name', '作者', 'string')
  const userResult = await txRepo.save(user)
  
  // 注意：HarmonyOS 事务中无法立即查询刚插入的数据
  // 使用 insertId 直接关联
  const post = new EntityData('Post')
  post.addProperty('title', '文章标题', 'string')
  post.addProperty('userId', userResult.insertId, 'number')
  
  // 创建 Post 的 Repository 也需要用于保存
  const postTxRepo = new Repository('Post')
  await postTxRepo.save(post)
})
```

---

## 只读事务

只读事务适用于纯查询场景，可以提高并发性能：

```typescript
const options = TransactionOptions.readOnly()

await userRepo.transactionWithOptions(async (txRepo) => {
  // 只允许查询操作
  const users = await txRepo.findAll()
  const count = await txRepo.count()
  
  // 尝试写操作会失败
  // await txRepo.save(user)  // Error!
}, options)
```

---

## 事务超时与重试

### 设置超时

```typescript
const options = TransactionOptions.withTimeout(5000)  // 5 秒超时

try {
  await userRepo.transactionWithOptions(async (txRepo) => {
    // 长时间操作...
    await longRunningOperation()
  }, options)
} catch (e) {
  // 可能是超时错误
  console.log('事务超时或失败')
}
```

### 设置重试

```typescript
const options = TransactionOptions.withRetry(3, 200)  // 重试 3 次，间隔 200ms

await userRepo.transactionWithOptions(async (txRepo) => {
  // 如果失败，会自动重试最多 3 次
  await txRepo.save(userData)
}, options)
```

---

## 完整示例

### 转账场景

```typescript
import { Repository, EntityData, TransactionOptions } from '@aspect/ocorm'

async function transfer(fromId: number, toId: number, amount: number) {
  const accountRepo = new Repository('Account')
  
  const options = TransactionOptions.fromConfig({
    isolation: IsolationLevel.SERIALIZABLE,
    timeout: 10000,
    retries: 2
  })
  
  const result = await accountRepo.transactionWithOptions(async (txRepo) => {
    // 查询转出账户
    const fromAccount = await txRepo.findById(fromId)
    if (fromAccount === null) {
      throw new Error('转出账户不存在')
    }
    
    const fromBalance = fromAccount.getPropertyValue('balance') as number
    if (fromBalance < amount) {
      throw new Error('余额不足')
    }
    
    // 查询转入账户
    const toAccount = await txRepo.findById(toId)
    if (toAccount === null) {
      throw new Error('转入账户不存在')
    }
    
    // 更新余额
    fromAccount.setPropertyValue('balance', fromBalance - amount)
    await txRepo.save(fromAccount)
    
    const toBalance = toAccount.getPropertyValue('balance') as number
    toAccount.setPropertyValue('balance', toBalance + amount)
    await txRepo.save(toAccount)
    
  }, options)
  
  return result.success
}
```

### 订单创建场景

```typescript
async function createOrder(userId: number, items: OrderItem[]) {
  const orderRepo = new Repository('Order')
  
  const result = await orderRepo.transaction(async (txRepo) => {
    // 1. 创建订单
    const order = new EntityData('Order')
    order.addProperty('userId', userId, 'number')
    order.addProperty('status', 'pending', 'string')
    order.addProperty('createdAt', Date.now(), 'number')
    
    const orderResult = await txRepo.save(order)
    const orderId = orderResult.insertId
    
    // 2. 创建订单项
    const orderItemRepo = new Repository('OrderItem')
    for (const item of items) {
      const orderItem = new EntityData('OrderItem')
      orderItem.addProperty('orderId', orderId, 'number')
      orderItem.addProperty('productId', item.productId, 'number')
      orderItem.addProperty('quantity', item.quantity, 'number')
      orderItem.addProperty('price', item.price, 'number')
      
      await orderItemRepo.save(orderItem)
    }
    
    // 3. 扣减库存
    const productRepo = new Repository('Product')
    for (const item of items) {
      const product = await productRepo.findById(item.productId)
      if (product === null) {
        throw new Error(`商品 ${item.productId} 不存在`)
      }
      
      const stock = product.getPropertyValue('stock') as number
      if (stock < item.quantity) {
        throw new Error(`商品 ${item.productId} 库存不足`)
      }
      
      product.setPropertyValue('stock', stock - item.quantity)
      await productRepo.save(product)
    }
  })
  
  if (!result.success) {
    throw new Error(`订单创建失败: ${result.errorMessage}`)
  }
  
  return result
}
```

---

## 注意事项

1. **事务中查询限制**：HarmonyOS 的事务中可能无法立即查询到刚插入的数据，建议使用 `insertId` 直接关联
2. **异常处理**：回调函数中抛出的异常会导致事务回滚，并重新抛出给调用者
3. **避免长事务**：长时间持有事务会影响并发性能，应尽快完成事务
4. **隔离级别选择**：根据业务需求选择合适的隔离级别，不要盲目使用最高级别
5. **重试策略**：对于并发冲突频繁的场景，适当配置重试可以提高成功率
