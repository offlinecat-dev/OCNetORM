# 最佳实践

本文档总结 OCORM 在实际项目中的最佳实践和常见问题解决方案。

---

## 项目结构

### 推荐目录结构

```
src/
├── main/
│   └── ets/
│       ├── entities/           # 实体定义
│       │   ├── User.ets
│       │   ├── Article.ets
│       │   └── index.ets       # 统一导出
│       ├── repositories/       # 仓库层（可选）
│       │   ├── UserRepository.ets
│       │   └── ArticleRepository.ets
│       ├── services/           # 业务逻辑层
│       │   ├── UserService.ets
│       │   └── ArticleService.ets
│       ├── viewmodels/         # 视图模型
│       │   ├── UserViewModel.ets
│       │   └── ArticleViewModel.ets
│       ├── database/           # 数据库配置
│       │   └── DBInit.ets      # 初始化配置
│       └── pages/              # 页面组件
```

### 实体定义文件示例

```typescript
// entities/User.ets
import { defineEntity, ColumnType } from '@aspect/ocorm'

// 定义实体
defineEntity('User', {
  tableName: 'users',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'name', type: ColumnType.TEXT, nullable: false },
    { property: 'email', type: ColumnType.TEXT, unique: true },
    { property: 'age', type: ColumnType.INTEGER },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER },
    { property: 'updatedAt', name: 'updated_at', type: ColumnType.INTEGER },
    { property: 'deletedAt', name: 'deleted_at', type: ColumnType.INTEGER }
  ],
  softDelete: true
})

// 导出实体名称常量
export const USER_ENTITY = 'User'
```

### 统一初始化

```typescript
// database/DBInit.ets
import { OCORMInit, DatabaseConfig, LogLevel } from '@aspect/ocorm'
import '../entities/index'  // 先导入实体定义

export async function initDatabase(context: Context): Promise<void> {
  const config = new DatabaseConfig('app.db')
  config.enableLogger = true
  config.loggerLevel = LogLevel.INFO
  config.setQueryCache(true, 200, 60000)
  
  await OCORMInit(context, {
    config: config
  })
}
```

---

## 性能优化

### 1. 合理使用查询缓存

```typescript
// ✅ 推荐：频繁读取的数据使用缓存
const user = await userRepo.findById(userId)  // 默认使用缓存

// ✅ 推荐：实时性要求高时禁用缓存
const balance = await accountRepo.findById(accountId, false, false)

// ✅ 推荐：根据场景配置缓存
const cache = QueryCache.getInstance()
cache.configure({
  maxSize: 500,      // 根据数据量调整
  ttlMs: 300000,     // 根据更新频率调整
  enabled: true
})
```

### 2. 批量操作优化

```typescript
// ❌ 避免：循环单条插入
for (const item of items) {
  await repo.save(item)  // 每次都执行 SQL
}

// ✅ 推荐：使用批量插入
await repo.batchInsert(items)  // 一次性插入

// ✅ 推荐：大数据量快速导入（禁用钩子和验证）
await repo.batchInsert(items, BatchInsertOptions.createFast())
```

### 3. 分页查询

```typescript
// ❌ 避免：一次性加载所有数据
const allUsers = await userRepo.findAll()

// ✅ 推荐：分页加载
const result = await userRepo.findPaginated(1, 20)
console.log(`共 ${result.total} 条，当前显示 ${result.data.length} 条`)
```

### 4. 异步查询优化

```typescript
// ✅ 推荐：大数据量使用异步查询（TaskPool 优化）
const users = await userRepo.findAllAsync()

// ✅ 推荐：QueryExecutor 异步查询
const executor = new QueryExecutor(queryBuilder)
const results = await executor.getAsync()
```

### 5. 关联数据延迟加载

```typescript
// ❌ 避免：总是预加载关联（可能不需要）
const users = await executor.get()  // 每个用户都查询关联

// ✅ 推荐：按需加载关联
const qb = userRepo.createQueryBuilder()
  .withLazy('posts')  // 延迟加载

// 需要时才加载
if (needPosts) {
  qb.with('posts')
}
```

### 6. 选择必要的列

```typescript
// ❌ 避免：查询所有列
const users = await executor.get()  // SELECT *

// ✅ 推荐：只查询需要的列
const qb = userRepo.createQueryBuilder()
  .select(['id', 'name', 'email'])  // 只查询必要列
```

### 7. 事务批量操作

```typescript
// ✅ 推荐：多个操作放入同一事务
await userRepo.transaction(async (repo) => {
  await repo.save(user1)
  await repo.save(user2)
  await repo.save(user3)
})  // 自动提交或回滚
```

---

## 实体设计规范

### 1. 命名规范

```typescript
// 实体名称：PascalCase
defineEntity('User', { ... })
defineEntity('ArticleCategory', { ... })

// 表名：snake_case 复数
tableName: 'users'
tableName: 'article_categories'

// 列名：snake_case
{ property: 'createdAt', name: 'created_at' }
{ property: 'userId', name: 'user_id' }
```

### 2. 主键设计

```typescript
// ✅ 推荐：使用自增整数主键
{ property: 'id', primaryKey: true }  // 默认自增

// ✅ 可选：UUID 作为主键（不自增）
{ property: 'id', primaryKey: true, autoIncrement: false }
```

### 3. 时间戳字段

```typescript
// ✅ 推荐：始终包含创建和更新时间
defineEntity('Article', {
  tableName: 'articles',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'title', type: ColumnType.TEXT },
    { property: 'createdAt', name: 'created_at', type: ColumnType.INTEGER },
    { property: 'updatedAt', name: 'updated_at', type: ColumnType.INTEGER }
  ]
})

// Repository 会自动更新 updated_at
```

### 4. 软删除配置

```typescript
// ✅ 推荐：需要数据恢复的实体启用软删除
defineEntity('Order', {
  tableName: 'orders',
  columns: [
    { property: 'id', primaryKey: true },
    { property: 'deletedAt', name: 'deleted_at', type: ColumnType.INTEGER }
  ],
  softDelete: true
})
```

---

## 错误处理

### 1. 统一错误处理

```typescript
import { 
  ExecutionError, 
  ValidationError, 
  TransactionRollbackError,
  EntityNotRegisteredError 
} from '@aspect/ocorm'

async function saveUser(userData: EntityData): Promise<SaveResult> {
  try {
    return await userRepo.save(userData)
  } catch (error) {
    if (error instanceof ValidationError) {
      // 数据验证失败
      console.error('验证失败:', error.message)
    } else if (error instanceof ExecutionError) {
      // SQL 执行失败
      console.error('数据库错误:', error.message)
    } else if (error instanceof TransactionRollbackError) {
      // 事务回滚
      console.error('事务失败:', error.message)
    } else {
      // 其他错误
      console.error('未知错误:', error)
    }
    throw error
  }
}
```

### 2. 事务错误处理

```typescript
try {
  await userRepo.transaction(async (repo) => {
    await repo.save(user)
    await repo.save(profile)
    
    // 业务逻辑检查
    if (someConditionFailed) {
      throw new Error('业务检查失败')  // 自动回滚
    }
  })
} catch (error) {
  if (error instanceof TransactionRollbackError) {
    console.error('事务已回滚:', error.message)
  }
}
```

### 3. 验证错误处理

```typescript
import { ValidationMetadataStorage } from '@aspect/ocorm'

// 注册验证规则
const storage = ValidationMetadataStorage.getInstance()
storage.registerRule('User', 'email', { type: 'email' })
storage.registerRule('User', 'name', { type: 'required' })
storage.registerRule('User', 'name', { type: 'length', min: 2, max: 50 })

// save 时自动验证
try {
  await userRepo.save(userData)  // 验证失败会抛出 ValidationError
} catch (error) {
  if (error instanceof ValidationError) {
    console.error('验证失败:', error.message)
  }
}
```

---

## 日志配置

### 开发环境

```typescript
import { Logger, LogLevel } from '@aspect/ocorm'

// 开发环境：详细日志
const logger = Logger.getInstance()
logger.configure(true, LogLevel.DEBUG)
```

### 生产环境

```typescript
// 生产环境：仅错误日志（避免敏感信息泄露）
const logger = Logger.getInstance()
logger.configure(true, LogLevel.ERROR)
```

### 自定义日志监控

```typescript
// 启用日志历史记录（用于分析）
const logger = Logger.getInstance()
logger.setRecordHistory(true)

// 执行查询...

// 获取日志历史
const history = logger.getLogHistory()
console.log('SQL 执行历史:', history)

// 清空历史
logger.clearLogHistory()
```

---

## 常见问题

### Q1: 实体未注册错误

```
错误：EntityNotRegisteredError: 实体 'User' 未注册
```

**原因**：在创建 Repository 之前未定义实体。

**解决**：
```typescript
// ✅ 确保先定义实体
import './entities/User'  // 导入实体定义

// 然后再创建 Repository
const userRepo = new Repository('User')
```

### Q2: 数据库未初始化错误

```
错误：ExecutionError: 数据库未初始化
```

**原因**：未调用 OCORMInit 或调用未完成。

**解决**：
```typescript
// ✅ 在 EntryAbility 中初始化
export default class EntryAbility extends UIAbility {
  async onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): Promise<void> {
    await initDatabase(this.context)  // 等待初始化完成
  }
}
```

### Q3: 软删除实体查询不到数据

```typescript
// 问题：启用软删除后，已删除数据查询不到
const user = await userRepo.findById(1)  // null
```

**解决**：
```typescript
// 方式一：包含已删除数据
const user = await userRepo.findById(1, true)

// 方式二：使用 QueryBuilder
const qb = userRepo.createQueryBuilder().withDeleted()
```

### Q4: 缓存数据不一致

```typescript
// 问题：更新后查询到旧数据
await userRepo.save(updatedUser)
const user = await userRepo.findById(1)  // 可能返回旧数据
```

**解决**：
```typescript
// Repository.save 会自动使缓存失效
// 如果仍有问题，手动清除缓存
const cache = QueryCache.getInstance()
cache.invalidate('User', 1)

// 或者禁用缓存查询
const user = await userRepo.findById(1, false, false)
```

### Q5: 事务中操作未生效

```typescript
// 问题：事务中的操作未提交
await userRepo.transaction(async (repo) => {
  const result = await repo.save(user)
  // result.success 为 true，但数据未保存
})
```

**原因**：可能是异步操作未正确等待。

**解决**：
```typescript
// ✅ 确保所有操作都使用 await
await userRepo.transaction(async (repo) => {
  await repo.save(user1)
  await repo.save(user2)
  // 不要漏掉 await
})
```

### Q6: 关联数据未加载

```typescript
// 问题：关联数据为空
const user = await userRepo.findById(1)
console.log(user?.getRelatedValue('posts'))  // null
```

**解决**：
```typescript
// 使用 QueryBuilder 加载关联
const qb = userRepo.createQueryBuilder().with('posts')
const executor = new QueryExecutor(qb)
const users = await executor.get()

// 现在可以访问关联数据
const posts = users[0]?.getRelatedValue('posts')
```

### Q7: 批量插入部分失败

```typescript
// 问题：批量插入时部分数据失败
const result = await userRepo.batchInsert(users)
console.log(result.insertedCount)  // 小于 totalCount
```

**解决**：
```typescript
// 检查结果
if (!result.success) {
  console.error('批量插入失败:', result.errorMessage)
  console.log('失败索引:', result.failedIndexes)
}

// 使用事务确保原子性
const options = new BatchInsertOptions()
options.useTransaction = true
await userRepo.batchInsert(users, options)
```

---

## 安全建议

### 1. 避免 SQL 注入

```typescript
// ✅ OCORM 使用参数化查询，天然防止 SQL 注入
qb.where('name', ConditionOperator.EQUAL, userInput)

// ❌ 避免：直接拼接 SQL（如果使用原生查询）
```

### 2. 敏感数据处理

```typescript
// ✅ 日志系统自动脱敏
// SQL 中的字符串值会被替换为 [***]
// 长数字（如手机号）会被替换为 [***]

// ✅ 生产环境使用 ERROR 级别日志
logger.configure(true, LogLevel.ERROR)
```

### 3. 数据验证

```typescript
// ✅ 始终验证用户输入
import { ValidationMetadataStorage } from '@aspect/ocorm'

// 注册验证规则
const storage = ValidationMetadataStorage.getInstance()
storage.registerRule('User', 'email', { type: 'email' })
storage.registerRule('User', 'name', { type: 'required' })
storage.registerRule('User', 'name', { type: 'length', min: 2, max: 50 })

// save 时自动验证
try {
  await userRepo.save(userData)  // 验证失败会抛出 ValidationError
} catch (error) {
  if (error instanceof ValidationError) {
    console.error('验证失败:', error.message)
  }
}
