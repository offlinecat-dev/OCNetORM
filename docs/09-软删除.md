# 软删除

本章节介绍 OCORM 的软删除功能，实现逻辑删除而不是物理删除数据。

## 概述

软删除（Soft Delete）是一种数据管理策略，通过标记数据为"已删除"状态而不是实际从数据库中移除数据。这样可以：

- 保护数据，防止误删
- 保留历史数据，支持数据恢复
- 便于审计和追溯

## 启用软删除

### 在实体注册时启用

```typescript
import {
  registerEntity,
  registerAutoIncrementPrimaryKey,
  createEntityOptions
} from 'ocorm'

// 启用软删除（softDelete: true）
registerEntity('User', createEntityOptions('users', true))

// 注册主键和列...
registerAutoIncrementPrimaryKey('User', 'id', 'id')

const storage = MetadataStorage.getInstance()

// deleted_at 列用于标记删除时间
const deletedAtColumn = new ColumnMetadata('deletedAt', 'deleted_at')
deletedAtColumn.columnType = ColumnType.INTEGER
deletedAtColumn.isNullable = true
storage.registerColumn('User', deletedAtColumn)
```

### 自动管理 deleted_at

OCORM 会自动管理 `deleted_at` 列：

- **删除时**：将 `deleted_at` 设置为当前时间戳
- **查询时**：自动过滤 `deleted_at IS NULL` 的数据
- **恢复时**：将 `deleted_at` 设置为 `null`

## 软删除操作

### 软删除数据

```typescript
const repo = new Repository('User')

// 软删除（设置 deleted_at）
await repo.removeById(1)

// 或使用实体对象
const user = await repo.findById(1)
await repo.remove(user)
```

### 物理删除（强制删除）

如果需要真正删除数据（跳过软删除）：

```typescript
const repo = new Repository('User')

// 强制物理删除（忽略软删除设置）
await repo.forceRemoveById(1)

// 或使用实体对象
const user = await repo.findById(1)
await repo.forceRemove(user)
```

### 恢复已删除数据

```typescript
const repo = new Repository('User')

// 恢复被软删除的数据
await repo.restore(1)
```

## 查询软删除数据

### 包含已删除数据

默认情况下，查询只返回未删除的数据。使用 `withDeleted()` 方法包含已删除的数据：

```typescript
const repo = new Repository('User')

// 查询所有数据（包括已删除）
const allUsers = await repo.createQueryBuilder()
  .withDeleted()
  .getMany()
```

### 仅查询已删除数据

使用 `onlyDeleted()` 方法仅查询已删除的数据：

```typescript
const repo = new Repository('User')

// 仅查询已删除的数据
const deletedUsers = await repo.createQueryBuilder()
  .onlyDeleted()
  .getMany()
```

### 在 findAll 和 findById 中使用

```typescript
const repo = new Repository('User')

// findAll 包含已删除数据
const allUsers = await repo.findAll(true)

// findById 包含已删除数据
const user = await repo.findById(1, true)
```

## 分页查询中的软删除

```typescript
const repo = new Repository('User')

// 分页查询（默认不包含已删除数据）
const result1 = await repo.findPaginated(1, 20)

// 分页查询（包含已删除数据）
const result2 = await repo.findPaginated(1, 20, true)

// 分页查询（仅已删除数据）
const deletedResult = await repo.createQueryBuilder()
  .onlyDeleted()
  .paginate(1, 20)
  .getPaginated()
```

## 统计数量

```typescript
const repo = new Repository('User')

// 统计未删除的数据（默认）
const activeCount = await repo.count()

// 统计所有数据（包括已删除）
const allCount = await repo.count(true)
```

## 完整示例

### 软删除服务

```typescript
// services/UserSoftDeleteService.ts
import { Repository, EntityData, ConditionOperator } from 'ocorm'

export class UserSoftDeleteService {
  private repo: Repository

  constructor() {
    this.repo = new Repository('User')
  }

  // 软删除用户
  async softDelete(userId: number, deletedBy?: string): Promise<boolean> {
    const user = await this.repo.findById(userId)
    
    if (!user) {
      return false
    }
    
    // 可以在这里记录删除操作
    if (deletedBy) {
      user.setPropertyValue('deletedBy', deletedBy)
    }
    
    const result = await this.repo.remove(user)
    return result.success
  }

  // 恢复用户
  async restore(userId: number): Promise<boolean> {
    try {
      await this.repo.restore(userId)
      return true
    } catch (error) {
      console.error(`恢复用户失败: ${error.message}`)
      return false
    }
  }

  // 永久删除（需确认）
  async permanentDelete(userId: number): Promise<boolean> {
    const user = await this.repo.findById(userId, true)  // 包含已删除
    
    if (!user) {
      return false
    }
    
    // 检查是否已删除超过 30 天（示例业务逻辑）
    const deletedAt = user.getPropertyValue('deletedAt') as number
    if (deletedAt && Date.now() - deletedAt > 30 * 24 * 60 * 60 * 1000) {
      const result = await this.repo.forceRemove(user)
      return result.success
    }
    
    console.warn('数据未超过保留期限，不能永久删除')
    return false
  }

  // 获取已删除用户列表
  async getDeletedUsers(page: number = 1, pageSize: number = 20) {
    return await this.repo.createQueryBuilder()
      .onlyDeleted()
      .orderBy('deletedAt', 'DESC')
      .paginate(page, pageSize)
      .getPaginated()
  }

  // 获取所有用户（包括已删除）
  async getAllUsersWithDeleted(page: number = 1, pageSize: number = 20) {
    return await this.repo.createQueryBuilder()
      .withDeleted()
      .orderBy('createdAt', 'DESC')
      .paginate(page, pageSize)
      .getPaginated()
  }
}
```

### 回收站功能

```typescript
// services/RecycleBinService.ts
import { Repository, EntityData, ConditionOperator } from 'ocorm'

const DELETED_THRESHOLD = 30 * 24 * 60 * 60 * 1000  // 30 天

export class RecycleBinService {
  private userRepo: Repository

  constructor() {
    this.userRepo = new Repository('User')
  }

  // 获取回收站中的项目
  async getRecycleBinItems(entityType: string, page: number = 1) {
    const result = await this.userRepo.createQueryBuilder()
      .onlyDeleted()
      .where('deletedAt', ConditionOperator.GREATER, Date.now() - DELETED_THRESHOLD)
      .paginate(page, 20)
      .getPaginated()
    
    return result
  }

  // 恢复回收站中的项目
  async restoreFromRecycleBin(entityType: string, id: number): Promise<boolean> {
    return await this.userRepo.restore(id)
  }

  // 清理过期项目（永久删除）
  async cleanExpiredItems(entityType: string): Promise<number> {
    const cutoffTime = Date.now() - DELETED_THRESHOLD
    
    const expiredUsers = await this.userRepo.createQueryBuilder()
      .onlyDeleted()
      .where('deletedAt', ConditionOperator.LESS, cutoffTime)
      .getMany()
    
    let deletedCount = 0
    for (const user of expiredUsers) {
      const result = await this.userRepo.forceRemove(user)
      if (result.success) {
        deletedCount++
      }
    }
    
    return deletedCount
  }
}
```

## 与钩子配合使用

软删除可以与生命周期钩子配合使用：

```typescript
import { EntityHooks } from 'ocorm'

const softDeleteHooks = new EntityHooks(
  // beforeSave
  (data) => {
    // 正常保存逻辑
  },
  
  // afterLoad
  (data) => {
    // 检查是否已删除
    const deletedAt = data.getProperty('deletedAt')?.value as number
    if (deletedAt) {
      data.setTransient('isDeleted', true)
      data.setTransient('deletedAtDate', new Date(deletedAt))
    }
  },
  
  // beforeDelete
  (data) => {
    // 可以在这里添加额外的删除前逻辑
    console.info(`用户 ${data.getPropertyValue('name')} 即将被删除`)
  }
)

registerEntity('User', createEntityOptions('users', true, softDeleteHooks))
```

## 注意事项

### 性能考虑

软删除会影响查询性能，因为每次查询都会添加 `deleted_at IS NULL` 条件。对于大型表，建议：

- 在 `deleted_at` 列上创建索引
- 定期清理过期数据
- 考虑分表策略

### 唯一约束

如果实体有唯一约束，软删除后再次创建相同数据可能会冲突。解决方案：

- 使用复合唯一约束包含 `deleted_at`
- 使用唯一约束 + 时间戳组合
- 在业务逻辑中处理冲突

### 外键约束

删除操作不会自动处理外键约束。如果有外键指向被软删除的记录，需要在业务逻辑中处理。

## 下一步

- [数据库迁移](10-数据库迁移.md) - 了解如何在迁移中添加软删除
- [性能优化](13-性能优化.md) - 优化软删除查询性能




