# 完整示例

本章节提供一个完整的业务场景示例，展示如何使用 OCORM 构建一个电商应用的数据层。

## 业务场景

构建一个简单的电商系统，包含以下功能：
- 用户管理（注册、登录、信息管理）
- 商品管理（商品列表、详情）
- 订单管理（下单、查询、状态更新）
- 用户收藏商品（多对多关系）

## 项目结构

```
entry/src/main/ets/
├── common/
│   └── constants/
│       └── OrderStatus.ts
├── database/
│   └── DBManager.ts
├── entities/
│   ├── index.ts
│   ├── User.ts
│   ├── Product.ts
│   └── Order.ts
├── associations/
│   └── index.ts
├── hooks/
│   └── index.ts
├── repositories/
│   ├── index.ts
│   ├── UserRepository.ts
│   ├── ProductRepository.ts
│   └── OrderRepository.ts
├── services/
│   ├── index.ts
│   ├── UserService.ts
│   ├── ProductService.ts
│   └── OrderService.ts
├── mappers/
│   ├── index.ts
│   └── ViewModels.ts
└── pages/
    └── commerce/
        ├── ProductList.ets
        └── OrderDetail.ets
```

## 1. 定义常量

```typescript
// common/constants/OrderStatus.ts
export enum OrderStatus {
  PENDING = 0,       // 待付款
  PAID = 1,          // 已付款
  SHIPPED = 2,       // 已发货
  COMPLETED = 3,     // 已完成
  CANCELLED = 4,     // 已取消
  REFUNDED = 5       // 已退款
}

export class OrderStatusText {
  static getText(status: OrderStatus): string {
    const texts: Record<number, string> = {
      [OrderStatus.PENDING]: '待付款',
      [OrderStatus.PAID]: '已付款',
      [OrderStatus.SHIPPED]: '已发货',
      [OrderStatus.COMPLETED]: '已完成',
      [OrderStatus.CANCELLED]: '已取消',
      [OrderStatus.REFUNDED]: '已退款'
    }
    return texts[status] || '未知'
  }
}
```

## 2. 定义实体

```typescript
// entities/User.ts
import {
  MetadataStorage,
  ColumnMetadata,
  ColumnType,
  registerEntity,
  registerAutoIncrementPrimaryKey,
  createEntityOptions,
  EntityHooks
} from 'ocorm'

export function registerUserEntity(): void {
  // 创建用户钩子
  const userHooks = new EntityHooks(
    // beforeSave: 自动填充时间戳
    (data) => {
      const now = Date.now()
      if (!data.getProperty('createdAt')) {
        data.setPropertyValue('createdAt', now)
      }
      data.setPropertyValue('updatedAt', now)
      
      // 邮箱转小写
      const email = data.getProperty('email')?.value as string
      if (email) {
        data.setPropertyValue('email', email.toLowerCase())
      }
    },
    // afterLoad: 计算年龄
    (data) => {
      const birthDate = data.getProperty('birthDate')?.value as number
      if (birthDate) {
        const age = Math.floor((Date.now() - birthDate) / (365.25 * 24 * 60 * 60 * 1000))
        data.setTransient('age', age)
      }
    }
  )

  registerEntity('User', createEntityOptions('users', false, userHooks))
  registerAutoIncrementPrimaryKey('User', 'id', 'id')

  const storage = MetadataStorage.getInstance()

  // name
  const nameColumn = new ColumnMetadata('name', 'name')
  nameColumn.columnType = ColumnType.TEXT
  nameColumn.isNullable = false
  storage.registerColumn('User', nameColumn)

  // email
  const emailColumn = new ColumnMetadata('email', 'email')
  emailColumn.columnType = ColumnType.TEXT
  emailColumn.isUnique = true
  storage.registerColumn('User', emailColumn)

  // password
  const passwordColumn = new ColumnMetadata('password', 'password')
  passwordColumn.columnType = ColumnType.TEXT
  passwordColumn.isNullable = false
  storage.registerColumn('User', passwordColumn)

  // phone
  const phoneColumn = new ColumnMetadata('phone', 'phone')
  phoneColumn.columnType = ColumnType.TEXT
  storage.registerColumn('User', phoneColumn)

  // status
  const statusColumn = new ColumnMetadata('status', 'status')
  statusColumn.columnType = ColumnType.INTEGER
  statusColumn.defaultValue = 1  // 1: 正常, 0: 禁用
  storage.registerColumn('User', statusColumn)
}

// entities/Product.ts
import { registerEntity, registerAutoIncrementPrimaryKey, createEntityOptions } from 'ocorm'

export function registerProductEntity(): void {
  registerEntity('Product', createEntityOptions('products'))
  registerAutoIncrementPrimaryKey('Product', 'id', 'id')

  const storage = MetadataStorage.getInstance()

  // name
  const nameColumn = new ColumnMetadata('name', 'name')
  nameColumn.columnType = ColumnType.TEXT
  nameColumn.isNullable = false
  storage.registerColumn('Product', nameColumn)

  // description
  const descColumn = new ColumnMetadata('description', 'description')
  descColumn.columnType = ColumnType.TEXT
  storage.registerColumn('Product', descColumn)

  // price
  const priceColumn = new ColumnMetadata('price', 'price')
  priceColumn.columnType = ColumnType.REAL
  priceColumn.isNullable = false
  storage.registerColumn('Product', priceColumn)

  // stock
  const stockColumn = new ColumnMetadata('stock', 'stock')
  stockColumn.columnType = ColumnType.INTEGER
  stockColumn.defaultValue = 0
  storage.registerColumn('Product', stockColumn)

  // category
  const categoryColumn = new ColumnMetadata('category', 'category')
  categoryColumn.columnType = ColumnType.TEXT
  storage.registerColumn('Product', categoryColumn)

  // status
  const statusColumn = new ColumnMetadata('status', 'status')
  statusColumn.columnType = ColumnType.INTEGER
  statusColumn.defaultValue = 1  // 1: 上架, 0: 下架
  storage.registerColumn('Product', statusColumn)
}

// entities/Order.ts
import { registerEntity, registerAutoIncrementPrimaryKey, registerPrimaryKey, createEntityOptions } from 'ocorm'
import { OrderStatus } from '../../common/constants/OrderStatus'

export function registerOrderEntity(): void {
  registerEntity('Order', createEntityOptions('orders', true))  // 启用软删除
  registerAutoIncrementPrimaryKey('Order', 'id', 'id')
  registerPrimaryKey('Order', 'userId', 'user_id')

  const storage = MetadataStorage.getInstance()

  // user_id
  const userIdColumn = new ColumnMetadata('userId', 'user_id')
  userIdColumn.columnType = ColumnType.INTEGER
  userIdColumn.isNullable = false
  storage.registerColumn('Order', userIdColumn)

  // order_no
  const orderNoColumn = new ColumnMetadata('orderNo', 'order_no')
  orderNoColumn.columnType = ColumnType.TEXT
  orderNoColumn.isUnique = true
  storage.registerColumn('Order', orderNoColumn)

  // total_amount
  const amountColumn = new ColumnMetadata('totalAmount', 'total_amount')
  amountColumn.columnType = ColumnType.REAL
  amountColumn.isNullable = false
  storage.registerColumn('Order', amountColumn)

  // status
  const statusColumn = new ColumnMetadata('status', 'status')
  statusColumn.columnType = ColumnType.INTEGER
  statusColumn.defaultValue = OrderStatus.PENDING
  storage.registerColumn('Order', statusColumn)

  // deleted_at (软删除)
  const deletedAtColumn = new ColumnMetadata('deletedAt', 'deleted_at')
  deletedAtColumn.columnType = ColumnType.INTEGER
  storage.registerColumn('Order', deletedAtColumn)
}
```

## 3. 定义关联

```typescript
// associations/index.ts
import { MetadataStorage, RelationType, ManyToManyMetadata } from 'ocorm'

export function registerAllAssociations(): void {
  const storage = MetadataStorage.getInstance()

  // User -> Order (一对多)
  storage.registerRelation('User', {
    type: RelationType.ONE_TO_MANY,
    targetEntity: 'Order',
    propertyName: 'orders',
    inverseKey: 'user_id'
  })

  // Order -> User (多对一)
  storage.registerRelation('Order', {
    type: RelationType.MANY_TO_ONE,
    targetEntity: 'User',
    propertyName: 'user',
    foreignKey: 'user_id'
  })

  // User -> Product (收藏，多对多)
  storage.registerManyToMany('User', new ManyToManyMetadata(
    'User', 'Product', 'favoriteProducts',
    'user_favorites', 'user_id', 'product_id'
  ))
}
```

## 4. 定义仓储

```typescript
// repositories/UserRepository.ts
import { Repository, EntityData, ConditionOperator } from 'ocorm'

export class UserRepository {
  private repo: Repository

  constructor() {
    this.repo = new Repository('User')
  }

  async findById(id: number): Promise<EntityData | null> {
    return await this.repo.findById(id)
  }

  async findByEmail(email: string): Promise<EntityData | null> {
    const users = await this.repo.createQueryBuilder()
      .where('email', ConditionOperator.EQUAL, email)
      .getOne()
    return users
  }

  async create(data: EntityData): Promise<number | null> {
    const result = await this.repo.save(data)
    return result.success ? result.insertId : null
  }

  async update(data: EntityData): Promise<boolean> {
    const result = await this.repo.save(data)
    return result.success
  }

  async findAll(): Promise<EntityData[]> {
    return await this.repo.findAll()
  }
}

// repositories/ProductRepository.ts
import { Repository, EntityData, ConditionOperator } from 'ocorm'
import { PaginatedResult } from 'ocorm'

export class ProductRepository {
  private repo: Repository

  constructor() {
    this.repo = new Repository('Product')
  }

  async findById(id: number): Promise<EntityData | null> {
    return await this.repo.findById(id)
  }

  async findOnSale(): Promise<EntityData[]> {
    return await this.repo.createQueryBuilder()
      .where('status', ConditionOperator.EQUAL, 1)
      .orderBy('createdAt', 'DESC')
      .getMany()
  }

  async findByCategory(category: string): Promise<EntityData[]> {
    return await this.repo.createQueryBuilder()
      .where('category', ConditionOperator.EQUAL, category)
      .andWhere('status', ConditionOperator.EQUAL, 1)
      .orderBy('price', 'ASC')
      .getMany()
  }

  async findPaginated(page: number, pageSize: number): Promise<PaginatedResult> {
    return await this.repo.createQueryBuilder()
      .where('status', ConditionOperator.EQUAL, 1)
      .orderBy('createdAt', 'DESC')
      .paginate(page, pageSize)
      .getPaginated()
  }

  async updateStock(id: number, stock: number): Promise<boolean> {
    const product = await this.repo.findById(id)
    if (product) {
      product.setPropertyValue('stock', stock)
      const result = await this.repo.save(product)
      return result.success
    }
    return false
  }
}

// repositories/OrderRepository.ts
import { Repository, EntityData, ConditionOperator } from 'ocorm'
import { OrderStatus } from '../../common/constants/OrderStatus'

export class OrderRepository {
  private repo: Repository

  constructor() {
    this.repo = new Repository('Order')
  }

  async findById(id: number): Promise<EntityData | null> {
    return await this.repo.findById(id)
  }

  async findByUserId(userId: number): Promise<EntityData[]> {
    return await this.repo.createQueryBuilder()
      .where('userId', ConditionOperator.EQUAL, userId)
      .orderBy('createdAt', 'DESC')
      .getMany()
  }

  async findByUserIdWithDeleted(userId: number): Promise<EntityData[]> {
    return await this.repo.createQueryBuilder()
      .where('userId', ConditionOperator.EQUAL, userId)
      .withDeleted()
      .orderBy('createdAt', 'DESC')
      .getMany()
  }

  async create(data: EntityData): Promise<number | null> {
    const result = await this.repo.save(data)
    return result.success ? result.insertId : null
  }

  async updateStatus(id: number, status: OrderStatus): Promise<boolean> {
    const order = await this.repo.findById(id)
    if (order) {
      order.setPropertyValue('status', status)
      const result = await this.repo.save(order)
      return result.success
    }
    return false
  }

  async cancelOrder(id: number): Promise<boolean> {
    return await this.updateStatus(id, OrderStatus.CANCELLED)
  }

  async softDelete(id: number): Promise<boolean> {
    const result = await this.repo.removeById(id)
    return result.success
  }

  async restore(id: number): Promise<boolean> {
    try {
      await this.repo.restore(id)
      return true
    } catch {
      return false
    }
  }
}
```

## 5. 定义服务

```typescript
// services/UserService.ts
import { UserRepository } from '../repositories/UserRepository'
import { EntityData } from 'ocorm'

export class UserService {
  private userRepo: UserRepository

  constructor() {
    this.userRepo = new UserRepository()
  }

  async register(name: string, email: string, password: string): Promise<number | null> {
    // 检查邮箱是否已存在
    const existing = await this.userRepo.findByEmail(email)
    if (existing) {
      throw new Error('邮箱已被注册')
    }

    const userData = EntityData.from('User', {
      name: name,
      email: email,
      password: password,  // 生产环境应加密
      status: 1
    })

    return await this.userRepo.create(userData)
  }

  async login(email: string, password: string): Promise<EntityData | null> {
    const user = await this.userRepo.findByEmail(email)
    if (!user) {
      return null
    }

    const storedPassword = user.getPropertyValue('password') as string
    if (storedPassword !== password) {
      return null
    }

    const status = user.getPropertyValue('status') as number
    if (status === 0) {
      throw new Error('账户已被禁用')
    }

    return user
  }

  async getUserById(id: number): Promise<EntityData | null> {
    return await this.userRepo.findById(id)
  }

  async updateProfile(id: number, updates: { name?: string; phone?: string }): Promise<boolean> {
    const user = await this.userRepo.findById(id)
    if (!user) {
      throw new Error('用户不存在')
    }

    if (updates.name) {
      user.setPropertyValue('name', updates.name)
    }
    if (updates.phone) {
      user.setPropertyValue('phone', updates.phone)
    }

    return await this.userRepo.update(user)
  }
}

// services/ProductService.ts
import { ProductRepository } from '../repositories/ProductRepository'
import { EntityData, ConditionOperator } from 'ocorm'

export class ProductService {
  private productRepo: ProductRepository

  constructor() {
    this.productRepo = new ProductRepository()
  }

  async getProductList(page: number = 1, pageSize: number = 20) {
    return await this.productRepo.findPaginated(page, pageSize)
  }

  async getProductDetail(id: number): Promise<EntityData | null> {
    return await this.productRepo.findById(id)
  }

  async getProductsByCategory(category: string): Promise<EntityData[]> {
    return await this.productRepo.findByCategory(category)
  }

  async reduceStock(productId: number, quantity: number): Promise<boolean> {
    const product = await this.productRepo.findById(productId)
    if (!product) {
      throw new Error('商品不存在')
    }

    const stock = product.getPropertyValue('stock') as number
    if (stock < quantity) {
      throw new Error('库存不足')
    }

    return await this.productRepo.updateStock(productId, stock - quantity)
  }
}

// services/OrderService.ts
import { OrderRepository } from '../repositories/OrderRepository'
import { ProductService } from './ProductService'
import { UserRepository } from '../repositories/UserRepository'
import { EntityData, ConditionOperator } from 'ocorm'
import { OrderStatus } from '../../common/constants/OrderStatus'

export class OrderService {
  private orderRepo: OrderRepository
  private productService: ProductService
  private userRepo: UserRepository

  constructor() {
    this.orderRepo = new OrderRepository()
    this.productService = new ProductService()
    this.userRepo = new UserRepository()
  }

  async createOrder(userId: number, items: Array<{ productId: number; quantity: number }>): Promise<number | null> {
    // 验证用户
    const user = await this.userRepo.findById(userId)
    if (!user) {
      throw new Error('用户不存在')
    }

    // 验证商品并计算总价
    let totalAmount = 0
    const orderItems: Array<EntityData> = []

    for (const item of items) {
      const product = await this.productService.getProductDetail(item.productId)
      if (!product) {
        throw new Error(`商品 ${item.productId} 不存在`)
      }

      const price = product.getPropertyValue('price') as number
      totalAmount += price * item.quantity

      orderItems.push(product)
    }

    // 生成订单号
    const orderNo = `ORD${Date.now()}${Math.floor(Math.random() * 1000)}`

    // 创建订单
    const orderData = EntityData.from('Order', {
      userId: userId,
      orderNo: orderNo,
      totalAmount: totalAmount,
      status: OrderStatus.PENDING
    })

    const orderId = await this.orderRepo.create(orderData)

    // 扣减库存
    for (const item of items) {
      await this.productService.reduceStock(item.productId, item.quantity)
    }

    return orderId
  }

  async getOrderDetail(orderId: number): Promise<EntityData | null> {
    return await this.orderRepo.findById(orderId)
  }

  async getUserOrders(userId: number): Promise<EntityData[]> {
    return await this.orderRepo.findByUserId(userId)
  }

  async payOrder(orderId: number): Promise<boolean> {
    const order = await this.orderRepo.findById(orderId)
    if (!order) {
      throw new Error('订单不存在')
    }

    const status = order.getPropertyValue('status') as OrderStatus
    if (status !== OrderStatus.PENDING) {
      throw new Error('订单状态不支持付款')
    }

    return await this.orderRepo.updateStatus(orderId, OrderStatus.PAID)
  }

  async cancelOrder(orderId: number): Promise<boolean> {
    const order = await this.orderRepo.findById(orderId)
    if (!order) {
      throw new Error('订单不存在')
    }

    const status = order.getPropertyValue('status') as OrderStatus
    if (status !== OrderStatus.PENDING) {
      throw new Error('当前订单状态不能取消')
    }

    return await this.orderRepo.cancelOrder(orderId)
  }

  async deleteOrder(orderId: number): Promise<boolean> {
    return await this.orderRepo.softDelete(orderId)
  }
}
```

## 6. 定义 ViewModel 映射

```typescript
// mappers/ViewModels.ts
import { ViewModelMapper, EntityData } from 'ocorm'
import { OrderStatus, OrderStatusText } from '../common/constants/OrderStatus'

// Product ViewModels
export class ProductItemVM {
  id: number = 0
  name: string = ''
  price: number = 0
  category: string = ''
}

export class ProductDetailVM {
  id: number = 0
  name: string = ''
  description: string = ''
  price: number = 0
  stock: number = 0
  category: string = ''
}

// Order ViewModels
export class OrderItemVM {
  id: number = 0
  orderNo: string = ''
  totalAmount: number = 0
  status: number = 0
  statusText: string = ''
  createdAt: string = ''
}

export class OrderDetailVM {
  id: number = 0
  orderNo: string = ''
  totalAmount: number = 0
  status: number = 0
  statusText: string = ''
  createdAt: string = []
  userName: string = []
}

// User ViewModels
export class UserProfileVM {
  id: number = 0
  name: string = ''
  email: string = ''
  phone: string = ''
}

// 映射器
export class CommerceMapper {
  // Product → ProductItemVM
  static toProductItem(data: EntityData): ProductItemVM {
    return ViewModelMapper.toViewModel<ProductItemVM>(
      data,
      () => new ProductItemVM(),
      (data, vm) => {
        vm.id = data.getPropertyValue('id') as number
        vm.name = data.getPropertyValue('name') as string
        vm.price = data.getPropertyValue('price') as number
        vm.category = data.getPropertyValue('category') as string
      }
    )
  }

  static toProductItems(dataArray: EntityData[]): ProductItemVM[] {
    return ViewModelMapper.toViewModelArray<ProductItemVM>(
      dataArray,
      () => new ProductItemVM(),
      (data, vm) => {
        vm.id = data.getPropertyValue('id') as number
        vm.name = data.getPropertyValue('name') as string
        vm.price = data.getPropertyValue('price') as number
        vm.category = data.getPropertyValue('category') as string
      }
    )
  }

  // Order → OrderItemVM
  static toOrderItem(data: EntityData): OrderItemVM {
    return ViewModelMapper.toViewModel<OrderItemVM>(
      data,
      () => new OrderItemVM(),
      (data, vm) => {
        vm.id = data.getPropertyValue('id') as number
        vm.orderNo = data.getPropertyValue('orderNo') as string
        vm.totalAmount = data.getPropertyValue('totalAmount') as number
        vm.status = data.getPropertyValue('status') as number
        vm.statusText = OrderStatusText.getText(vm.status)
        vm.createdAt = new Date(data.getPropertyValue('createdAt') as number)
          .toLocaleString()
      }
    )
  }

  static toOrderItems(dataArray: EntityData[]): OrderItemVM[] {
    return ViewModelMapper.toViewModelArray<OrderItemVM>(
      dataArray,
      () => new OrderItemVM(),
      (data, vm) => {
        vm.id = data.getPropertyValue('id') as number
        vm.orderNo = data.getPropertyValue('orderNo') as string
        vm.totalAmount = data.getPropertyValue('totalAmount') as number
        vm.status = data.getPropertyValue('status') as number
        vm.statusText = OrderStatusText.getText(vm.status)
        vm.createdAt = new Date(data.getPropertyValue('createdAt') as number)
          .toLocaleString()
      }
    )
  }
}
```

## 7. 页面使用示例

```typescript
// pages/commerce/ProductList.ets
import { ProductService } from '../../services/ProductService'
import { CommerceMapper, ProductItemVM } from '../../mappers/ViewModels'
import { OrderService } from '../../services/OrderService'

@Entry
@Component
struct ProductListPage {
  private productService = new ProductService()
  private orderService = new OrderService()
  @State products: ProductItemVM[] = []
  @State loading: boolean = false
  @State page: number = 1
  private pageSize: number = 20

  aboutToAppear() {
    this.loadProducts()
  }

  async loadProducts() {
    this.loading = true
    try {
      const result = await this.productService.getProductList(this.page, this.pageSize)
      this.products = CommerceMapper.toProductItems(result.data)
    } finally {
      this.loading = false
    }
  }

  async buyProduct(productId: number) {
    try {
      const orderId = await this.orderService.createOrder(1, [
        { productId: productId, quantity: 1 }
      ])
      if (orderId) {
        prompt.showToast({ message: '下单成功' })
      }
    } catch (error) {
      prompt.showToast({ message: `下单失败: ${error.message}` })
    }
  }

  build() {
    Column() {
      if (this.loading) {
        Progress()
          .width(50)
          .height(50)
      } else {
        List() {
          ForEach(this.products, (product: ProductItemVM) => {
            ListItem() {
              Column() {
                Text(product.name)
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                Text(`价格: ¥${product.price}`)
                  .fontColor('#ff6666')
                Button('购买')
                  .onClick(() => this.buyProduct(product.id))
              }
              .padding(10)
            }
          })
        }
      }
    }
  }
}
```

## 8. 数据库初始化

```typescript
// database/DBManager.ts
import { DatabaseManager, DatabaseConfig, SchemaBuilder } from 'ocorm'
import { relationalStore } from '@kit.ArkData'
import { registerAllEntities } from '../entities'
import { registerAllAssociations } from '../associations'

export async function initDatabase(context: Context): Promise<void> {
  // 1. 注册实体
  registerAllEntities()
  
  // 2. 注册关联
  registerAllAssociations()
  
  // 3. 配置数据库
  const config = new DatabaseConfig(
    'ecommerce.db',
    relationalStore.SecurityLevel.S1
  )
  config.enableQueryCache = true
  config.queryCacheMaxSize = 200
  
  // 4. 初始化
  await DatabaseManager.getInstance().initialize(context, config)
  
  // 5. 创建表
  const schemaBuilder = new SchemaBuilder()
  const result = await schemaBuilder.createAllTablesWithManager()
  
  if (result.success) {
    console.info(`数据库初始化成功，创建了 ${result.successCount} 张表`)
  } else {
    console.error(`建表失败: ${result.results[0]?.errorMessage}`)
  }
}
```

## 运行效果

通过以上代码，你将拥有一个完整的电商应用数据层，包括：

1. **用户模块**：注册、登录、个人信息管理
2. **商品模块**：商品列表、分页查询、库存管理
3. **订单模块**：下单、付款、取消、软删除
4. **数据映射**：EntityData 与 ViewModel 的双向转换

## 下一步

- [性能优化](13-性能优化.md) - 优化电商系统性能
- [项目结构推荐](15-项目结构推荐.md) - 完善项目组织方式
- [错误处理](12-错误处理.md) - 完善错误处理机制




