# 错误处理

本章节介绍 OCORM 的错误处理机制，包括错误类型、错误码和最佳实践。

## 错误类型体系

OCORM 定义了完善的错误类型体系，便于精确处理各类异常。

### 错误类继承结构

```
OrmError (基类)
├── MetadataError        // 元数据相关错误
├── QueryError          // 查询相关错误
├── MappingError        // 数据映射错误
├── TransactionError    // 事务相关错误
├── DatabaseError       // 数据库连接/执行错误
├── RelationError       // 关联关系错误
├── HookError          // 生命周期钩子错误
└── SoftDeleteError    // 软删除相关错误
```

## 常用错误类

### MetadataError - 元数据错误

```typescript
import { EntityNotRegisteredError, PrimaryKeyNotDefinedError } from 'ocorm'

try {
  const repo = new Repository('User')
} catch (error) {
  if (error instanceof EntityNotRegisteredError) {
    console.error(`实体未注册: ${error.entityName}`)
    // 处理：确保先注册实体
  }
}

try {
  // ...
} catch (error) {
  if (error instanceof PrimaryKeyNotDefinedError) {
    console.error(`实体 ${error.entityName} 未定义主键`)
    // 处理：在实体中注册主键
  }
}
```

### QueryError - 查询错误

```typescript
import { InvalidConditionError, SubQueryError } from 'ocorm'

try {
  await repo.createQueryBuilder()
    .where('invalid_column', ConditionOperator.EQUAL, 'value')
    .getMany()
} catch (error) {
  if (error instanceof InvalidConditionError) {
    console.error(`条件错误: ${error.message}`)
    // 处理：检查列名是否正确
  }
}
```

### DatabaseError - 数据库错误

```typescript
import { ConnectionError, ExecutionError, DatabaseNotInitializedError } from 'ocorm'

try {
  await DatabaseManager.getInstance().initialize(context, config)
} catch (error) {
  if (error instanceof ConnectionError) {
    console.error(`数据库连接失败: ${error.message}`)
    // 处理：检查配置是否正确
  }
}

try {
  const store = DatabaseManager.getInstance().getStore()
} catch (error) {
  if (error instanceof DatabaseNotInitializedError) {
    console.error('数据库未初始化')
    // 处理：先调用 initialize
  }
}
```

### TransactionError - 事务错误

```typescript
import { TransactionRollbackError } from 'ocorm'

try {
  await repo.transaction(async (txRepo) => {
    // 事务操作...
  })
} catch (error) {
  if (error instanceof TransactionRollbackError) {
    console.error(`事务回滚: ${error.message}`)
    // 处理：检查事务中的操作是否正确
  }
}
```

### HookError - 钩子错误

```typescript
import { HookExecutionError } from 'ocorm'

try {
  await repo.save(userData)
} catch (error) {
  if (error instanceof HookExecutionError) {
    console.error(`钩子执行失败: ${error.message}`)
    // 处理：检查钩子逻辑
  }
}
```

## 错误码常量

OCORM 定义了标准错误码常量：

```typescript
import {
  ERROR_ENTITY_NOT_REGISTERED,
  ERROR_DUPLICATE_ENTITY,
  ERROR_INVALID_COLUMN_TYPE,
  ERROR_COLUMN_NOT_FOUND,
  ERROR_PRIMARY_KEY_NOT_DEFINED,
  ERROR_INVALID_CONDITION,
  ERROR_TYPE_CONVERSION_FAILED,
  ERROR_TRANSACTION_ROLLBACK,
  ERROR_DATABASE_CONNECTION_FAILED,
  ERROR_RELATION_NOT_FOUND
} from 'ocorm'

// 使用错误码进行比较
if (error.code === ERROR_ENTITY_NOT_REGISTERED) {
  // 处理未注册实体错误
}
```

## 全局错误处理

### 封装统一错误处理

```typescript
// utils/ErrorHandler.ts
type ErrorHandler = (error: OrmError) => void

class ErrorHandler {
  private static handlers: Map<string, ErrorHandler> = new Map()

  // 注册错误处理器
  static register(code: string, handler: ErrorHandler): void {
    this.handlers.set(code, handler)
  }

  // 处理错误
  static handle(error: OrmError): void {
    const handler = this.handlers.get(error.code)
    if (handler) {
      handler(error)
    } else {
      // 默认处理
      console.error(`未处理的错误 [${error.code}]: ${error.message}`)
    }
  }

  // 包装异步函数
  static wrap<T>(fn: () => Promise<T>): Promise<T> {
    return fn().catch(error => {
      this.handle(error)
      throw error
    })
  }
}

// 注册处理器
ErrorHandler.register('ENTITY_NOT_REGISTERED', (error) => {
  console.error(`实体 ${error.message} 未注册，请先调用 registerEntity`)
})

ErrorHandler.register('PRIMARY_KEY_NOT_DEFINED', (error) => {
  console.error(`主键未定义: ${error.message}`)
})

// 使用
async function safeSave(userData: EntityData): Promise<SaveResult> {
  try {
    return await repo.save(userData)
  } catch (error) {
    ErrorHandler.handle(error as OrmError)
    return SaveResult.createFailure((error as Error).message)
  }
}
```

### 使用 Promise 封装

```typescript
// 异步操作封装
async function withErrorHandling<T>(
  operation: () => Promise<T>,
  errorMessage: string
): Promise<T | null> {
  try {
    return await operation()
  } catch (error) {
    if (error instanceof OrmError) {
      console.error(`${errorMessage}: ${error.message}`)
    } else {
      console.error(`${errorMessage}: ${(error as Error).message}`)
    }
    return null
  }
}

// 使用示例
const user = await withErrorHandling(
  () => repo.findById(1),
  '查询用户失败'
)

if (user) {
  // 处理用户数据
}
```

## 错误恢复策略

### 重试机制

```typescript
async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  delayMs: number = 1000
): Promise<T> {
  let lastError: Error | null = null
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation()
    } catch (error) {
      lastError = error as Error
      
      // 如果是临时性错误，等待后重试
      if (isTransientError(lastError)) {
        await new Promise(resolve => setTimeout(resolve, delayMs))
        console.info(`重试 ${i + 1}/${maxRetries}`)
      } else {
        // 非临时性错误，直接抛出
        throw error
      }
    }
  }
  
  throw lastError
}

// 判断是否为临时性错误
function isTransientError(error: Error): boolean {
  const transientCodes = [
    'BUSY',           // 数据库忙
    'LOCKED',         // 表被锁定
    'TEMPORARY'       // 临时错误
  ]
  
  return transientCodes.some(code => 
    error.message.toUpperCase().includes(code)
  )
}
```

### 回退策略

```typescript
async function withFallback<T>(
  primary: () => Promise<T>,
  fallback: () => Promise<T>
): Promise<T> {
  try {
    return await primary()
  } catch (error) {
    console.warn(`主操作失败，使用回退: ${error.message}`)
    return await fallback()
  }
}

// 使用示例：从缓存回退到数据库
const getUser = withFallback(
  () => cache.get(key),
  () => repo.findById(id)
)
```

## 调试技巧

### 启用详细日志

```typescript
const config = new DatabaseConfig('myapp.db', relationalStore.SecurityLevel.S1)
config.enableLogger = true
config.loggerLevel = LogLevel.DEBUG
```

### 记录错误上下文

```typescript
try {
  // 操作...
} catch (error) {
  // 记录详细错误信息
  console.error({
    message: error.message,
    code: error.code,
    stack: error.stack,
    context: {
      entityName: 'User',
      operation: 'save',
      data: userData
    }
  })
}
```

## 最佳实践

### 1. 精确捕获错误

```typescript
// ✅ 好的做法：精确捕获
try {
  await repo.save(userData)
} catch (error) {
  if (error instanceof HookExecutionError) {
    // 处理钩子错误
  } else if (error instanceof OrmError) {
    // 处理 ORM 错误
  }
}

// ❌ 不好的做法：捕获所有错误
try {
  await repo.save(userData)
} catch (error) {
  console.error(error)  // 不知道具体错误类型
}
```

### 2. 提供有意义的错误信息

```typescript
// ✅ 好的做法
if (!user) {
  throw new UserNotFoundError(userId)
}

// ❌ 不好的做法
if (!user) {
  throw new Error('not found')
}
```

### 3. 记录错误上下文

```typescript
try {
  await complexOperation()
} catch (error) {
  // 记录操作上下文
  logger.error(`操作失败: ${operationName}`, {
    error: error.message,
    params: operationParams,
    timestamp: Date.now()
  })
}
```

### 4. 清理资源

```typescript
let store: relationalStore.RdbStore | null = null
try {
  store = DatabaseManager.getInstance().getStore()
  // 操作...
} finally {
  // 确保资源被释放
  if (store) {
    // 清理逻辑
  }
}
```

## 下一步

- [性能优化](13-性能优化.md) - 减少错误发生的策略
- [最佳实践](15-项目结构推荐.md) - 项目组织方式




